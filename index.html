<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>TinyLoom</title>
<!-- Load vis.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
<!-- Load vis.js CSS -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
<!-- Load diff_match_patch library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch_uncompressed.js"></script>
<!-- Load axios library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.7/axios.min.js"></script>
<style>
#mynetwork {
    width: 100%;
    height: 100vh;
    border: 1px solid lightgray;
    float: left;
} 

#textEditor {
    position: absolute;
    display: none;
    width: 50%;
    height: 100vh;
    right: 0;
}

#background-text {
    display: none;
    align-items: center;
    justify-content: center;
    height: 100vh;
    position: absolute;
    width: 100%;
    top: 0;
    left: 0;
}

#settingsModal {
    display: none;
    position: fixed;
    z-index: 10;
    left: 10%;
    top: 10%;
    width: 80%;
    height: 80%;
    background-color: rgba(255, 255, 255, 0.9); /* white with 90% opacity */
    border: 1px solid #ccc;
    overflow: auto;
}

#nodeContextMenu {
    background-color: white; /* Ensure there is a background */
    color: black; /* Text color */
    border: 1px solid #ccc; /* Border to make it stand out */
    padding: 10px; /* Some padding around the content */
    z-index: 1000; /* High z-index to ensure it's above other elements */
    position: absolute; /* Position it absolutely */
    display: none; /* Hide it by default */
}

#nodeContextMenu ul {
    list-style: none; /* Remove default list styling */
    margin: 0; /* Remove default margin */
    padding: 0; /* Remove default padding */
}

#nodeContextMenu li {
    padding: 5px 10px; /* Add some padding to each list item */
    cursor: pointer; /* Change cursor to pointer to indicate clickable items */
}

#nodeContextMenu li:hover {
    background-color: #f0f0f0; /* Add a hover effect for list items */
}
</style>
</head>
<body>
<div id="nodeContextMenu" class="context-menu">
    <ul>
        <li id="hideNode">Hide</li>
        <li id="unhideNode">Unhide</li>
        <li id="bookmarkNode">Bookmark</li>
    </ul>
</div>
<div style="position: absolute; top: 10px; right: 10px; z-index: 5;">
<input type="password" id="together-api-key-input" placeholder="Enter Together API Key" style="background-color: pink;"><br>
<input type="password" id="openai-api-key-input" placeholder="Enter Openai API Key" style="background-color: pink;">
<div id="model-checkboxes" style="margin-left: 10px;">
    <label><input type="checkbox" class="model-checkbox" value="mistral" checked style="accent-color: red;"> Mistral</label><br>
    <label><input type="checkbox" class="model-checkbox" value="mistral-instruct" checked style="accent-color: blue;"> Mistral Instruct</label><br>
    <label><input type="checkbox" class="model-checkbox" value="mixtral" checked style="accent-color: orange;"> Mixtral</label><br>
    <label><input type="checkbox" class="model-checkbox" value="mixtral-instruct" checked style="accent-color: green;"> Mixtral Instruct</label><br>
    <label><input type="checkbox" class="model-checkbox" value="llama2" checked style="accent-color: purple;"> LLaMA2</label><br>
    <label><input type="checkbox" class="model-checkbox" value="minihf" style="accent-color: yellow;"> MiniHF</label><br>
    <label><input type="checkbox" class="model-checkbox" value="gpt3t" checked style="accent-color: #afd7af;"> Gpt4</label><br>
    <label><input type="checkbox" class="model-checkbox" value="gpt4t" checked style="accent-color: #d7afff;"> Gpt3</label><br>
    <a href="https://docs.together.ai/docs/inference-models" target="_blank" title="Any of the models at the link available on request." style="font-size: smaller;">More?</a><br>
    <!-- Additional models can be added here -->
</div>
</select>
</div>
    <div style="position: absolute; top: 10px; left: 10px; z-index: 5;">
        <button id="btn-settings">Settings</button>
        <button id="btn-download">Download</button>
        <button id="clear-data-btn">Clear Data</button>
    </div>
    <div id="mynetwork"></div>
    <div id="textEditor">
        <textarea id="fullText" style="width:100%; height:100%;"></textarea>
    </div>
    <div id="background-text">
      Hello and welcome to tinyloom! This is a little loom in one file.<br>
      Click anywhere to create your first node. Right click to exit the editor.<br>
      Add your together.ai api key, and press 'r' to generate! Happy looming!<br>
      <br>
      Double click on nodes to see and edit the full text.<br>
      Click on nodes to check them out for generation.<br>
    </div>
    <!-- Settings modal for model configuration -->
    <div id="settingsModal">
        <div style="display: flex; justify-content: space-between; height: 50%;">
            <div style="width: 50%; padding-right: 10px;">
                <h3>Settings</h3>
        <h2>Model Configuration</h2>
        <label for="max-tokens-input">Max Tokens:</label>
        <input type="number" id="max-tokens-input" value="50" step="10"><br>
        <label for="temperature-input">Temperature:</label>
        <input type="number" step="0.1" id="temperature-input" value="0.7"><br>
        <label for="top-p-input">Top P:</label>
        <input type="number" step="0.1" id="top-p-input" value="0.7"><br>
        <label for="top-k-input">Top K:</label>
        <input type="number" id="top-k-input" value="50"><br>
        <label for="repetition-penalty-input">Repetition Penalty:</label>
        <input type="number" step="0.1" id="repetition-penalty-input" value="1"><br>
        <label for="stop-sequence-input">Stop Sequence:</label>
        <input type="text" id="stop-sequence-input" value="</s>"><br>
        <label for="completions-input">Completions:</label>
        <input type="number" id="completions-input" value="1">
        <label>(per model!)</label><br>
        <div style="margin-top: 20px;">
            <h3>Display Settings</h3>
            <label><input type="checkbox" id="toggle-model-colors"> Use Model Colors</label><br>
        </div>
            </div>
            <div style="width: 50%; padding-left: 10px;">
                <h3>JSON Data</h3>
                <textarea id="json-data-textarea" style="width:100%; height:90%;"></textarea>
                <button id="export-json-btn">Export JSON</button>
                <button id="import-json-btn">Import JSON</button>
            </div>
        </div>
        <button id="save-settings-btn">Save Settings</button>
    </div>
<script>
// On page load, retrieve the API key from localStorage
document.addEventListener("DOMContentLoaded", function () {
  // Load data from localStorage on page load
  var savedData = localStorage.getItem("data");
  if (savedData) {
    data = JSON.parse(savedData);
    updateVisualization(Object.values(data.nodes));
  }
  // Hide the background text if there are nodes
  if (Object.keys(data.nodes).length > 0) {
    document.getElementById("background-text").style.display = "none";
  }
  var savedApiKey = localStorage.getItem("togetherApiKey");
  if (savedApiKey) {
    const apiKeyInput = document.getElementById("together-api-key-input");
    apiKeyInput.value = savedApiKey.trim().replace(/^"|"$/g, "");
    togetherApiKey = apiKeyInput.value;
    apiKeyInput.style.backgroundColor = "green";
  }
  savedApiKey = localStorage.getItem("openaiApiKey");
  if (savedApiKey) {
    const apiKeyInput = document.getElementById("openai-api-key-input");
    apiKeyInput.value = savedApiKey.trim().replace(/^"|"$/g, "");
    openaiApiKey = apiKeyInput.value;
    apiKeyInput.style.backgroundColor = "green";
  }
});

// Initialize data object to store nodes and edges
var data = { nodes: {} };

// Function to clear data from localStorage and reset visualization
function clearData() {
  localStorage.removeItem("data");
data = { nodes: {} }; // Reset data object
edges.clear(); // Clear edges from DataSet
nodes.clear(); // Clear nodes from DataSet
  document.getElementById("background-text").style.display = "flex"; // Show background text
}

function exportJSON() {
  console.log(data);
  const jsonData = JSON.stringify(data, null, 2);
  document.getElementById("json-data-textarea").value = jsonData;
}

// Function to import JSON data from the textarea
function importJSON() {
  const jsonData = document.getElementById("json-data-textarea").value;
  try {
    const parsedData = JSON.parse(jsonData);
    document.getElementById("background-text").style.display = "none";
    // Update the data object and visualization with the new data
    data = parsedData;
    updateVisualization(Object.values(data.nodes));
  } catch (error) {
    console.error("Error parsing JSON:", error);
    alert("Invalid JSON data.");
  }
}

// Function to export a full html with the data embedded
function downloadHTML() {
  var htmlContent = document.documentElement.outerHTML;
  htmlContent = htmlContent.replace(
"var data = " + JSON.stringify(data.nodes) + ";",
  );

  var blob = new Blob([htmlContent], { type: "text/html" });
  var url = URL.createObjectURL(blob);
  var a = document.createElement("a");
  a.href = url;
  a.download = "index.html";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
var dmp = new diff_match_patch();

var nodes = new vis.DataSet([]);
var edges = new vis.DataSet([]);

// Global variable to track if model colors are enabled
// Get the value from the toffle-model-colors checkbox
var useModelColors = document.getElementById("toggle-model-colors").checked;

// Function to update the visualization with new nodes
function updateVisualization(newNodes) {
  newNodes.forEach((node) => {
    // Use the last patch to set the label, if available
    const lastPatch =
      node.patches && node.patches.length > 0
        ? node.patches[node.patches.length - 1]
        : null;
    const label = lastPatch
      ? formatDiffsForDisplay(lastPatch.diffs)
      : node.text;
    const nodeColor = {
      border: getNodeBorderColor(node.type),
    };
    nodes.update({
      id: node.id,
      label: label,
      color: nodeColor,
      title: '<div class="info-box"><strong>Model:</strong> ' + node.type + '<br><strong>Bookmarked:</strong> ' + (node.bookmarked ? 'Yes' : 'No') + '</div>',
      parent: node.parent,
    });
    if (node.parent !== null) {
      edges.update({ from: node.parent, to: node.id });
    }
  });
}

updateVisualization(Object.values(data.nodes));

function getNodeBorderColor(nodeType) {
  if (!useModelColors) {
    console.log("Model colors are disabled")
    return "black"; // Return black when model colors are disabled
  }
  switch (nodeType) {
    case "mistral-instruct":
      return "blue";
    case "mixtral-instruct":
      return "green";
    case "mixtral":
      return "orange";
    case "llama2":
      return "purple";
    case "mistral":
      return "red";
    case "gpt3t":
      return "#afd7af";
    case "gpt4t":
      return "#d7afff";
    default:
      return "black"; // Default border color for unknown types
  }
}

// Function to update node colors based on the model type
function updateNodeColors() {
  nodes.forEach((node) => {
    const nodeColor = {
      border: getNodeBorderColor(data.nodes[node.id].type),
    };
    console.log("Node color:", nodeColor);
    nodes.update([{ id: node.id, color: nodeColor }]);
  });
}

// Helper function to check if there are any non-data nodes in the network
function hasNonDataNodes() {
  return (
    nodes.get({
      filter: function (node) {
        return node.group !== "data";
      },
    }).length > 0
  );
}

// Get the context menu element
var contextMenu = document.getElementById('nodeContextMenu');
// Create a network
const container = document.getElementById("mynetwork");

const visData = {
  nodes: nodes,
  edges: edges,
};
const options = {
  layout: {
    hierarchical: {
      sortMethod: "directed",
      levelSeparation: 400,
      nodeSpacing: 250,
    },
  },
  nodes: {
    shape: "box",
    size: 20,
    color: {
      background: "white",
      border: "grey", // Default border color
      highlight: {
        background: "white",
        border: "black",
      },
    },
    font: {
      size: 20,
      multi: true, // Enable multi-line text
    },
    borderWidth: 2,
    widthConstraint: {
      maximum: 250,
    },
  },
  edges: {
    smooth: true,
    arrows: { to: true },
  },
  physics: { enabled: false },
};
const network = new vis.Network(container, visData, options);

// Check if nodes are empty and display background text
if (!hasNonDataNodes()) {
  document.getElementById("background-text").style.display = "flex";
} else {
  document.getElementById("background-text").style.display = "none";
}

// Function to update the layout direction
function updateLayoutDirection(direction) {
  const options = {
    layout: {
      hierarchical: {
        direction: direction,
      },
    },
  };
  network.setOptions(options);
}

// Function to create a new node if the text has changed or if it's the first node
// Function to toggle the bookmark state of a node
function toggleBookmark(nodeId) {
  const node = data.nodes[nodeId];
  node.bookmarked = !node.bookmarked;
  updateVisualization([node]);
  localStorage.setItem("data", JSON.stringify(data));
}

// Function to toggle the visibility of a node
function toggleVisibility(nodeId) {
  const node = data.nodes[nodeId];
  node.hidden = !node.hidden;
  if (node.hidden) {
    nodes.remove({ id: nodeId });
  } else {
    nodes.add(node);
  }
  localStorage.setItem("data", JSON.stringify(data));
}
function createNodeIfTextChanged(originalText, newText, parentId, type) {
  if (originalText !== newText || !hasNonDataNodes()) {
    // Text has changed, or it's the first node, create a new node
    const newNodeId = !hasNonDataNodes()
      ? 1
      : Object.keys(data.nodes).length + 1;
    const patches = dmp.patch_make(originalText, newText);
    data.nodes[newNodeId] = {
      id: newNodeId,
      text: dmp.patch_toText(patches),
      patches: patches,
      parent: parentId,
      type: type, // Store the type of the node
      bookmarked: false,
      hidden: false,
    };

    // if the parentId was nan, then the new node is the root and we must set the checked out node
    if (isNaN(parentId)) {
      localStorage.setItem("checkedOutNodeId", newNodeId);
      console.log("Checked out node ID:", newNodeId);
    }

    updateVisualization([data.nodes[newNodeId]]);
    useModelColors = event.target.checked;
    updateNodeColors(); // Update only the node colors without re-rendering the entire tree
    if (type === "human") {
      network.selectNodes([newNodeId]);
      localStorage.setItem("checkedOutNodeId", newNodeId);
    }
    // Hide the background text when the first node is created
    document.getElementById("background-text").style.display = "none";
  }
}

// Close the settings modal
document.getElementById("settingsModal").style.display = "none";
console.log("Model configuration updated:", modelConfig);
// Function to format diffs for display
function formatDiffsForDisplay(diffs) {
  const deletions = diffs
    .filter((diff) => diff[0] === -1)
    .map((diff) => diff[1])
    .join(" ")
    .trim();
  const additions = diffs
    .filter((diff) => diff[0] === 1)
    .map((diff) => diff[1])
    .join(" ")
    .trim();
  const delStr = deletions ? `-${deletions}` : "";
  const addStr = additions ? `+${additions}` : "";
  return `${delStr} ${addStr}`.trim();
}

// Function to render the full text from patches
function renderFullTextFromPatches(nodeId) {
  let currentNode = data.nodes[nodeId];
  let pathToRoot = [];
  let fullText = "";

  // Traverse up the tree to collect the path to the root
  while (currentNode) {
    pathToRoot.push(currentNode);
    currentNode = data.nodes[currentNode.parent];
  }

  // Reverse the path to start from the root
  pathToRoot.reverse();

  // Apply the patches from the root to the current node
  pathToRoot.forEach((node) => {
    if (node.patches) {
      // Apply the patch to the current full text
      const patches = node.patches;
      const results = dmp.patch_apply(patches, fullText);
      fullText = results[0]; // Update the full text with the applied patch
    }
  });

  return fullText;
}

// Function to find the parent node of the current node
function findParentNode(nodeId) {
  const node = nodes.get(nodeId);
  console.log("With parent:", node.parent);
  return node && node.parent ? node.parent : null;
}

// Function to find the left and right sibling nodes of the current node
function findSiblingNodes(nodeId) {
  const parentNodeId = findParentNode(nodeId);
  if (parentNodeId) {
    const siblings = nodes.get({
      filter: function (n) {
        return parseInt(n.parent) === parseInt(parentNodeId);
      },
    });
    const index = siblings.findIndex(
      (sibling) => parseInt(sibling.id) === parseInt(nodeId),
    );
    const leftSibling = index > 0 ? siblings[index - 1].id : null;
    const rightSibling =
      index < siblings.length - 1 ? siblings[index + 1].id : null;
    return { leftSibling, rightSibling };
  }
  return { leftSibling: null, rightSibling: null };
}

// Function to find the child node with the longest text from the currently selected node's children
function findLongestTextChildNode(parentNodeId) {
  let longestNode = null;
  let maxLength = 0;
  nodes.forEach(function (node) {
    if (parseInt(node.parent) === parseInt(parentNodeId)) {
      const length = node.label.length;
      if (length > maxLength) {
        longestNode = node.id;
        maxLength = length;
      }
    }
  });
  return longestNode;
}
// Global variable to store the API key
var apiKey = "";

// Model configuration
var modelConfig = {
  model: "mistralai/Mixtral-8x7B-Instruct-v0.1",
  max_tokens: 50,
  request_type: "language-model-inference",
  temperature: 0.7,
  top_p: 0.7,
  top_k: 50,
  repetition_penalty: 1,
  stream_tokens: false,
  stop: ["</s>"],
  n: 1,
};

// List of model aliases
var modelAliases = {
  "mistral-instruct": "mistralai/Mistral-7B-Instruct-v0.2",
  "mixtral-instruct": "mistralai/Mixtral-8x7B-Instruct-v0.1",
  mixtral: "mistralai/Mixtral-8x7B-v0.1",
  llama2: "togethercomputer/llama-2-70b",
  mistral: "mistralai/Mistral-7B-v0.1",
  gpt3t: "gpt-3.5-turbo",
  gpt4t: "gpt-4-turbo-preview",
};

// Function to generate new output based on the given text and parent ID
function generateNewOutput(parentId) {
  const fullText = renderFullTextFromPatches(parentId);
  // Collect all selected models
  const selectedModels = Array.from(
    document.querySelectorAll(".model-checkbox:checked"),
  ).map((checkbox) => checkbox.value);
  // Determine the number of generations to perform
  const generations = modelConfig.n || 1;
  // Call the function to make an API call for text generation for each selected model
  selectedModels.forEach((modelAlias) => {
    for (let i = 0; i < generations; i++) {
      generateText(fullText, parentId, modelAlias);
    }
  });
}

const prePrompt = `Return to completion mode. Complete the given sentence as best you can, with no commentary.
Return only the completion. If the prompt requires creativity, be creative.
DO NOT SAY 'here are some possible completions'. Just return the completion.

Examples:
Prompt:
The quick brown fox
Completion: jumps over the lazy dog.
Prompt:
The capital of France is
Completion: Paris.

Prompt:
`;


// Function to make an API call for text generation
function generateText(fullText, parentId, type) {
  var config = Object.assign({}, modelConfig); // Clone the modelConfig object
  config.prompt = fullText;
  // type is the model alias. set the name
  config.model = modelAliases[type];

  let apiUrl = "https://api.together.xyz/v1/completions";
  let headers = {
    Authorization: "Bearer " + togetherApiKey,
  };

  // Check if the model alias is for OpenAI and set the appropriate API URL and headers
  if (type.startsWith('gpt')) {
    apiUrl = "https://api.openai.com/v1/chat/completions";
    headers = {
      'Content-Type': 'application/json',
      Authorization: "Bearer " + openaiApiKey,
    };
    // OpenAI expects the prompt in a different format
    config = {
      messages: [
        {
          role: "user",
          content: prePrompt + fullText,
        },
      ],
      max_tokens: modelConfig.max_tokens,
      temperature: modelConfig.temperature,
      top_p: modelConfig.top_p,
      n: modelConfig.n,
      stop: modelConfig.stop,
      model: modelAliases[type],
    };
  }

  // Remove the 'n' parameter as it's not supported by the axios call
  delete config.n;
  axios({
    method: "post",
    url: apiUrl,
    data: config,
    headers: headers,
    responseType: "text",
  })
    .then((response) => {
      // Remove the "data:" prefix if it exists and parse the JSON
      const responseData = response.data.replace(/^data: /, "");
      const jsonResponse = JSON.parse(responseData);
      var newText = "";
      if (type.startsWith('gpt')) {
        // OpenAI returns the response in a different format
        newText = " " + jsonResponse.choices[0].message.content;
      } else {
        newText = " " + jsonResponse.choices[0].text;
      }

      // Create a new node with the generated text and the model type
      createNodeIfTextChanged(fullText, fullText + newText, parentId, type);
    })
    .catch((error) => {
      console.error("Error during API call:", error);
    });
}
// Event listener for the background text to open the modal on the first click
document
  .getElementById("background-text")
  .addEventListener("click", function () {
    if (!hasNonDataNodes()) {
      document.getElementById("background-text").style.display = "none";
      document.getElementById("textEditor").style.display = "block";
      document.getElementById("fullText").value =
        "(Right click to save and the editor!\nEscape to close without saving!)";
    }
  });

network.on("click", function (params) {
  if (params.nodes.length > 0) {
    // Check if the text editor is open
    nodeId = params.nodes[0];
    const textEditor = document.getElementById("textEditor");
    if (textEditor.style.display === "block") {
      const fullText = renderFullTextFromPatches(nodeId);

      // Update the full text in the editor
      const fullTextElement = document.getElementById("fullText");
      fullTextElement.value = fullText;
      // Ensure the text editor scrolls to the bottom after updates
      requestAnimationFrame(() => {
        fullTextElement.scrollTop = fullTextElement.scrollHeight;
      });
      fullTextElement.scrollTop = fullTextElement.scrollHeight;
      fullTextElement.setAttribute("data-node-id", nodeId);

      // Also, make the text editor no longer the active element.
      fullTextElement.blur();
    }

    // Save the last clicked node ID to localStorage
    localStorage.setItem("checkedOutNodeId", nodeId);
  }
});

// Event listener for node clicks to show full text in a modal
network.on("doubleClick", function (params) {
  if (params.nodes.length > 0) {
    const nodeId = params.nodes[0];
    const fullText = renderFullTextFromPatches(nodeId);

    // Display the full text in a modal
    const fullTextElement = document.getElementById("fullText");
    fullTextElement.value = fullText;
    // Ensure the text editor scrolls to the bottom after updates
    requestAnimationFrame(() => {
      fullTextElement.scrollTop = fullTextElement.scrollHeight;
    });
    fullTextElement.scrollTop = fullTextElement.scrollHeight;
    fullTextElement.setAttribute("data-node-id", nodeId);

    document.getElementById("textEditor").style.display = "block";
  }
});

// Modify the event listener for the modal to call createNodeIfTextChanged with human type
window.addEventListener("contextmenu", function (event) {
  const textEditor = document.getElementById("textEditor");
  const fullTextElement = document.getElementById("fullText");
  if (event.target === textEditor || event.target === fullTextElement) {
    // Get the current text from the modal
    const newText = fullTextElement.value;
    const nodeId = parseInt(fullTextElement.getAttribute("data-node-id"));
    const originalText = renderFullTextFromPatches(nodeId);

    // Create a new node if the text has changed with type as 'human'
    createNodeIfTextChanged(originalText, newText, nodeId, "human");

    // Ensure the text editor scrolls to the bottom after updates
    requestAnimationFrame(() => {
      fullTextElement.scrollTop = fullTextElement.scrollHeight;
    });
    // Close the modal
    textEditor.style.display = "none";
    fullTextElement.scrollTop = fullTextElement.scrollHeight;
    event.preventDefault(); // Prevent the default context menu from showing
  }
});

// Event listener for the Escape key to close the modal regardless of focus
window.addEventListener("keydown", function (event) {
  if (
    (event.key === "Escape" || event.keyCode === 27) &&
    document.getElementById("textEditor").style.display === "block"
  ) {
    document.getElementById("textEditor").style.display = "none";
  }
});

// Event listener for the 'p' key to open settings
window.addEventListener("keydown", function (event) {
  if (event.key === "p" || event.keyCode === 80) {
    // if the editor is open, do nothing
    if (document.getElementById("textEditor").style.display === "block") {
      return;
    }
    // Toggle the settings modal
    document.getElementById("settingsModal").style.display =
      document.getElementById("settingsModal").style.display === "block"
        ? "none"
        : "block";
  }
});

// Event listener for the r key to generate new output
window.addEventListener("keydown", function (event) {
  if (event.key === "r" || event.keyCode === 82) {
    const fullTextElement = document.getElementById("fullText");
    // Check if the modal is open and focussed
    if (document.activeElement === fullTextElement) {
      return; // Exit the function if the modal is open
    }
    // Retrieve the last clicked node ID from localStorage
    const checkedOutNodeId = localStorage.getItem("checkedOutNodeId");

    if (checkedOutNodeId) {
      // Generate new output based on the checked-out node
      generateNewOutput(checkedOutNodeId);
    }
    event.preventDefault(); // Prevent the default action of the 'r' key
  }
});

// Event listener for the "Download" button
document.getElementById("btn-download").addEventListener("click", downloadHTML);

// Event listener for API key input to change background color
document
  .getElementById("together-api-key-input")
  .addEventListener("input", function (event) {
    const input = event.target;
    togetherApiKey = input.value.trim().replace(/^"|"$/g, "");
    if (togetherApiKey !== "") {
      // Save the API key to localStorage
      localStorage.setItem("togetherApiKey", togetherApiKey);
      input.style.backgroundColor = "green";
    } else {
      input.style.backgroundColor = "pink";
    }
  });

// Event listener for API key input to change background color
document
  .getElementById("openai-api-key-input")
  .addEventListener("input", function (event) {
    const input = event.target;
    openaiApiKey = input.value.trim().replace(/^"|"$/g, "");
    if (openaiApiKey !== "") {
      // Save the API key to localStorage
      localStorage.setItem("openaiApiKey", openaiApiKey);
      input.style.backgroundColor = "green";
    } else {
      input.style.backgroundColor = "pink";
    }
  });

// Event listener for model checkboxes to change model configuration
document.querySelectorAll(".model-checkbox").forEach((checkbox) => {
  checkbox.addEventListener("change", function (event) {
    const selectedModels = Array.from(
      document.querySelectorAll(".model-checkbox:checked"),
    ).map((checkbox) => checkbox.value);
  });
});

// Event listener for the 'Clear Data' button
document.getElementById("clear-data-btn").addEventListener("click", clearData);

// Event listener for the settings button to toggle the settings modal
document.getElementById("btn-settings").addEventListener("click", function () {
  const settingsModal = document.getElementById("settingsModal");
  settingsModal.style.display =
    settingsModal.style.display === "block" ? "none" : "block";
});

// Event listener for the toggle model colors checkbox
document
  .getElementById("toggle-model-colors")
  .addEventListener("change", function (event) {
    useModelColors = event.target.checked;
    updateNodeColors();
  });

// Event listener for the save settings button to update the model configuration
document
  .getElementById("save-settings-btn")
  .addEventListener("click", function () {
    modelConfig.max_tokens = parseInt(
      document.getElementById("max-tokens-input").value,
    );
    modelConfig.temperature = parseFloat(
      document.getElementById("temperature-input").value,
    );
    modelConfig.top_p = parseFloat(
      document.getElementById("top-p-input").value,
    );
    modelConfig.top_k = parseInt(document.getElementById("top-k-input").value);
    modelConfig.repetition_penalty = parseFloat(
      document.getElementById("repetition-penalty-input").value,
    );
    modelConfig.stop = [document.getElementById("stop-sequence-input").value];
    modelConfig.n = parseInt(
      document.getElementById("completions-input").value,
    );
    // Function to export JSON data to the textarea
  });

// Event listener for the export JSON button
document
  .getElementById("export-json-btn")
  .addEventListener("click", exportJSON);

// Event listener for the import JSON button
document
  .getElementById("import-json-btn")
  .addEventListener("click", importJSON);

// Event listener for right-click on the settings modal to close it
document
  .getElementById("settingsModal")
  .addEventListener("contextmenu", function (event) {
    this.style.display = "none";
    event.preventDefault(); // Prevent the default context menu
  });

// Event listener for the 'w', 'a', 'd', and 's' keys for navigation
window.addEventListener("keydown", function (event) {
  if (document.getElementById("textEditor").style.display === "block") {
    return; // Do not navigate if the text editor is open
  }
  const checkedOutNodeId = localStorage.getItem("checkedOutNodeId");
  let targetNodeId = null;
  switch (event.key) {
    case "w":
      targetNodeId = findParentNode(checkedOutNodeId);
      break;
    case "a":
      targetNodeId = findSiblingNodes(checkedOutNodeId).leftSibling;
      break;
    case "d":
      targetNodeId = findSiblingNodes(checkedOutNodeId).rightSibling;
      break;
    case "s":
      targetNodeId = findLongestTextChildNode(checkedOutNodeId);
      break;
  }
  if (targetNodeId !== null) {
    // instead of focusing on it, just make sure it is highlighted
    network.selectNodes([targetNodeId]);
    localStorage.setItem("checkedOutNodeId", targetNodeId); // Save the new checked-out node ID
  }
});

// Attach context menu to the network
network.on('oncontext', function (params) {
  // Prevent default context menu from appearing
  params.event.preventDefault();
  // Position the custom context menu at the pointer location
  contextMenu.style.top = params.pointer.DOM.y + 'px';
  contextMenu.style.left = params.pointer.DOM.x + 'px';
  // Display the custom context menu
  contextMenu.style.display = 'block';
});

// Hide the context menu when clicking elsewhere
network.on('click', function () {
    if (contextMenu.style.display === 'block') {
        contextMenu.style.display = 'none';
    }
});

// Event listeners for context menu actions
document.getElementById('hideNode').addEventListener('click', function () {
  const selectedNodes = network.getSelectedNodes();
  if (selectedNodes.length > 0) {
    toggleVisibility(selectedNodes[0]);
  }
  contextMenu.style.display = 'none';
});

document.getElementById('unhideNode').addEventListener('click', function () {
  // Implement unhide node logic here
  contextMenu.style.display = 'none';
});

document.getElementById('bookmarkNode').addEventListener('click', function () {
  const selectedNodes = network.getSelectedNodes();
  if (selectedNodes.length > 0) {
    toggleBookmark(selectedNodes[0]);
  }
  contextMenu.style.display = 'none';
});

</script>
</body>
</html>
