<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>MultiLoom</title>
<!-- Load vis.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
<!-- Load vis.js CSS -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
<!-- Load diff_match_patch library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch_uncompressed.js"></script>
<!-- Load axios library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.7/axios.min.js"></script>
<!-- Load uuid library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
<script type="importmap">
  {
    "imports": {
      "@google/generative-ai": "https://esm.run/@google/generative-ai"
    }
  }
</script>
<style>
body {
  margin: 0;
}

#mynetwork {
    display: block;
    width: 100%;
    height: 100vh;
    border: 1px solid lightgray;
    float: left;
} 

#textEditor {
    position: fixed;
    display: none;
    width: 60%;
    max-width: 60%;
    height: 94vh;
    top: 2%;
    right: 20vw;
    padding: 1vw;
    box-sizing: border-box;
    resize: both; /* Ensure the element is resizable */
    overflow: auto; /* Add scrollbars if needed */
    z-index: 100;
    cursor: move; /* Indicate that the element is movable */
}

#fullText {
    width: 100%;
    height: 100%;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    border: none;
    padding: 15px;
    box-sizing: border-box;
    resize: none;
}

#background-text {
    display: none;
    align-items: center;
    justify-content: center;
    height: 100vh;
    position: absolute;
    width: 100%;
    top: 0;
    left: 0;
}

#settingsModal {
    display: none;
    position: fixed;
    z-index: 10;
    left: 10%;
    top: 10%;
    width: 80%;
    height: 80%;
    padding: 10px;
    background-color: rgba(255, 255, 255, 0.9); /* white with 90% opacity */
    border: 1px solid #ccc;
    overflow: auto;
}

#nodeContextMenu {
    background-color: white; /* Ensure there is a background */
    color: black; /* Text color */
    border: 1px solid #ccc; /* Border to make it stand out */
    padding: 10px; /* Some padding around the content */
    z-index: 1000; /* High z-index to ensure it's above other elements */
    position: absolute; /* Position it absolutely */
    display: none; /* Hide it by default */
}

#nodeContextMenu ul {
    list-style: none; /* Remove default list styling */
    margin: 0; /* Remove default margin */
    padding: 0; /* Remove default padding */
}

#nodeContextMenu li {
    padding: 5px 10px; /* Add some padding to each list item */
    cursor: pointer; /* Change cursor to pointer to indicate clickable items */
}

#nodeContextMenu li:hover {
    background-color: #f0f0f0; /* Add a hover effect for list items */
}

#info-box {
    display: none;
    position: absolute;
    z-index: 1000;
    background-color: rgba(255, 255, 255, 0.8);
    color: black;
    border: 1px solid #ccc;
    padding: 10px;
    font-size: 12px;
    max-width: 300px;
}

#infoModal {
    display: none;
    position: fixed;
    padding: 10px;
    z-index: 10;
    left: 10%;
    top: 10%;
    width: 80%;
    height: 80%;
    background-color: rgba(255, 255, 255, 0.9); /* white with 90% opacity */
    border: 1px solid #ccc;
    overflow: auto;
}

#infoModal h3 {
    margin-top: 0;
}

#key-shortcuts-list {
    list-style: none;
    padding: 20px;
}

#key-shortcuts-list li {
    margin-bottom: 5px;
}

.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0,0,0); /* Fallback color */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
}

.modal-content {
    background-color: #fefefe;
    margin: 15% auto; /* 15% from the top and centered */
    padding: 20px;
    border: 1px solid #888;
    width: 80%; /* Could be more or less, depending on screen size */
}

.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
}

.close:hover,
.close:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}

/* Show the API keys dropdown on hover over the dropdown container */
#api-keys-dropdown:hover .dropdown-content,
#api-keys-dropdown .dropdown-content:hover {
    display: block;
}

/* Style the API key input fields */
.api-key-input {
    width: calc(100% - 24px); /* Full width minus padding */
    padding: 6px;
    margin-bottom: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

/* Style the dropdown button */
.dropbtn {
    background-color: #4CAF50;
    color: white;
    padding: 16px;
    font-size: 16px;
    border: none;
    cursor: pointer;
}

/* The container <div> - needed to position the dropdown content */
.dropdown {
    position: relative;
    display: inline-block;
}

/* Dropdown Content (Hidden by Default) */
.dropdown-content {
    display: none;
    position: absolute;
    background-color: #f9f9f9;
    min-width: 160px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 1;
}

/* Show the dropdown menu on hover */
.dropdown:hover .dropdown-content {
    display: block;
}

/* Style the checkboxes inside the dropdown */
.dropdown-content input[type="checkbox"] {
    margin-right: 10px;
}

/* Style the labels for the checkboxes */
.dropdown-content label {
    margin-right: 10px;
}
.model-checkbox-container {
    margin-bottom: 10px;
}

.model-checkbox {
    margin-right: 5px;
}

#model-configs-container,
#default-params-container {
    margin-top: 20px;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
}

#model-configs-container h3,
#default-params-container h3 {
    margin-top: 0;
}

.model-config-toggle {
    margin-left: 10px;
}

#default-config-display {
  font-family: Arial, sans-serif;
  font-size: 14px;
  color: #333;
  background: rgba(255, 255, 255, 0.8);
  padding: 5px;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

#default-max-tokens-display,
#default-temperature-display {
  display: inline-block;
  margin-right: 10px;
  transition: color 0.3s ease;
}
</style>
</head>
<body>
<div id="nodeContextMenu" class="context-menu">
    <ul>
        <li id="hideNode">Toggle Hide</li>
        <li id="bookmarkNode">Toggle Bookmark</li>
        <li id="deleteNode">Delete</li>
    </ul>
</div>
<div id="model-config-modal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <div id="api-keys-dropdown" class="dropdown">
            <button id="api-keys-dropdown-btn" class="dropbtn">API Keys</button>
            <div id="api-keys-container" class="dropdown-content">
                <input type="password" id="together-api-key-input" placeholder="Together.AI API Key" class="api-key-input">
                <input type="password" id="openai-api-key-input" placeholder="OpenAI API Key" class="api-key-input">
                <input type="password" id="mistral-api-key-input" placeholder="Mistral API Key" class="api-key-input">
                <input type="password" id="google-api-key-input" placeholder="Google API Key" class="api-key-input">
            </div>
        </div>
        <h2>Model Configuration</h2>
        <div id="default-params-container">
            <h3>Default Parameters</h3>
            <!-- Default parameters will be displayed and editable here -->
        </div>
        <div id="model-params-container">
            <h3>Model Parameters</h3>
            <!-- Default parameters will be displayed and editable here -->
        </div>
    </div>
</div>
<div id="default-config-display" style="position: absolute; top: 10px; left: 10px; z-index: 5;">
    <span id="default-max-tokens-display">Max Tokens: --</span>
    <span id="default-temperature-display" style="margin-left: 10px;">Temperature: --</span>
</div>
    <div id="mynetwork"></div>
    <div id="textEditor">
        <textarea id="fullText" wrap="soft"></textarea>
    </div>
    <div id="background-text">
      <div>Hello and welcome to MultiLoom! This is a little loom in one file.<br>
      <br>
      <b>Press '?' at any time to open a help menu.</b><br>
      <br>
      Click anywhere to create your first node. Tab to exit the editor.<br>
      Add your api keys in the model configs menu 'm', and press 'r' to generate!<br>
      Happy looming!<br>
      <br>
      Double click on nodes to see and edit the full text.<br>
      Click on nodes to check them out for generation.<br>
      <br>
      Navigate with wasd.<br></div>
    </div>
    <!-- Settings modal for model configuration -->
    <div id="settingsModal">
        <div style="display: flex; justify-content: space-between; height: 50%;">
            <div style="width: 50%; padding-right: 10px;">
                <h3>Settings</h3>
        <div style="margin-top: 20px;">
            <h3>Display Settings</h3>
            <label><input type="checkbox" id="toggle-model-colors"> Use Model Colors</label><br>
        </div>
            <h3>Background Color</h3>
            <input type="color" id="background-color-input" title="Choose background color" style="width: 50px; height: 50px; border: none; cursor: pointer;"><br>
            <h3>Tree Layout Settings</h3>
            <label for="level-separation-input">Level Separation:</label>
            <input type="number" id="level-separation-input" value="400"><br>
            <label for="node-spacing-input">Node Spacing:</label>
            <input type="number" id="node-spacing-input" value="250"><br>
            <label for="direction-select">Direction:</label>
            <select id="direction-select">
                <option value="LR">Left to Right</option>
                <option value="UD">Up to Down</option>
            </select><br>
            </div>
            <div style="width: 50%; padding-left: 10px;">
                <h3>JSON Data</h3>
                <textarea id="json-data-textarea" style="width:100%; height:90%;"></textarea>
                <button id="export-json-btn">Export JSON</button>
                <button id="import-json-btn">Import JSON</button>
            </div>
        </div>
        <button id="btn-download">Download</button>
        <button id="clear-data-btn">Clear Data</button>
    </div>
<div id="infoModal">
    <div style="display: flex; justify-content: space-between; height: 50%;">
        <div style="width: 50%; padding-right: 10px;">
            <h3>Key Shortcuts</h3>
            <ul id="key-shortcuts-list">
              <li><kbd>tab</kbd>: Open/close the editor</li>
              <li><kbd>m</kbd>: Open the model configs</li>
              <li><kbd>r</kbd>: Generate new output</li>
              <li><kbd>p</kbd>: Open settings</li>
              <li><kbd>Escape</kbd>: Close the editor and discard changes</li>
              <li><kbd>w</kbd>: Navigate to parent</li>
              <li><kbd>a</kbd>: Navigate to left sibling</li>
              <li><kbd>d</kbd>: Navigate to right sibling</li>
              <li><kbd>s</kbd>: Navigate to last read child</li>
              <li><kbd>W</kbd>: Increase the max tokens</li>
              <li><kbd>S</kbd>: Decrease the max tokens</li>
              <li><kbd>D</kbd>: Increase the temperature</li>
              <li><kbd>A</kbd>: Decrease the temperature</li>
              <li><kbd>Space</kbd>: Toggle visibility of selected node (you need to right click to unhide)</li>
              <li><kbd>Enter</kbd>: Toggle bookmark of selected node</li>
              <li><kbd>Delete</kbd>: Delete selected node (and all children!)</li>
            </ul>
            <h3>Mouse Options</h3>
            Left click to select a node. This will update the editor if it is open.
            Double click to open the editor on a node.
            Right click on a node for hide, bookmark or delete. These can also be done with keyboard shortcuts.
            Right click on the editor to close it.
        </div>
        <div style="width: 50%; padding-left: 10px;">
            <h3>Stats</h3>
            <div id="stats-container">
                <!-- Stats will be added here -->
            </div>
        </div>
    </div>
</div>
<script type='module'>
import {
  GoogleGenerativeAI,
  HarmBlockThreshold,
  HarmCategory,
} from "@google/generative-ai";

var togetherApiKey = "";
var openaiApiKey = "";
var mistralApiKey = "";
var googleApiKey = "";

// On page load, retrieve the API key from localStorage
document.addEventListener("DOMContentLoaded", function () {
  // Load the editor size
  const savedSize = JSON.parse(localStorage.getItem("textEditorSize"));
  const textEditor = document.getElementById("textEditor");
  const fullText = document.getElementById("fullText");
  if (savedSize) {
    textEditor.style.display = "block";
    // fullText.style.width = `${savedSize.width}px`;
    // fullText.style.height = `${savedSize.height}px`;
    textEditor.style.display = "none";
  }

  // Load data from localStorage on page load, unless 'data' is already popuplated
  var savedData = localStorage.getItem("data");
  if (savedData && !Object.keys(data.nodes).length) {
    data = JSON.parse(savedData);
    updateVisualization(Object.values(data.nodes));
  }

  // Hide the background text if there are nodes
  if (Object.keys(data.nodes).length > 0) {
    document.getElementById("background-text").style.display = "none";
  }

  var savedApiKey = localStorage.getItem("togetherApiKey");
  if (savedApiKey) {
    const apiKeyInput = document.getElementById("together-api-key-input");
    apiKeyInput.value = savedApiKey.trim().replace(/^"|"$/g, "");
    togetherApiKey = apiKeyInput.value;
    apiKeyInput.style.backgroundColor = "green";
  }
  savedApiKey = localStorage.getItem("openaiApiKey");
  if (savedApiKey) {
    const apiKeyInput = document.getElementById("openai-api-key-input");
    apiKeyInput.value = savedApiKey.trim().replace(/^"|"$/g, "");
    openaiApiKey = apiKeyInput.value;
    apiKeyInput.style.backgroundColor = "green";
  }
  savedApiKey = localStorage.getItem("mistralApiKey");
  if (savedApiKey) {
    const apiKeyInput = document.getElementById("mistral-api-key-input");
    apiKeyInput.value = savedApiKey.trim().replace(/^"|"$/g, "");
    mistralApiKey = apiKeyInput.value;
    apiKeyInput.style.backgroundColor = "green";
  }
  savedApiKey = localStorage.getItem("googleApiKey");
  if (savedApiKey) {
    const apiKeyInput = document.getElementById("google-api-key-input");
    apiKeyInput.value = savedApiKey.trim().replace(/^"|"$/g, "");
    googleApiKey = apiKeyInput.value;
    apiKeyInput.style.backgroundColor = "green";
  }

  document.getElementById("level-separation-input").value =
    localStorage.getItem("levelSeparation") || 400;
  document.getElementById("node-spacing-input").value =
    localStorage.getItem("nodeSpacing") || 250;
  document.getElementById("direction-select").value =
    localStorage.getItem("direction") || "UD";
});

// Initialize data object to store nodes and edges
var data = { nodes: {} };
window.data = data;

// Function to clear data from localStorage and reset visualization
function clearData() {
  localStorage.removeItem("data");
  localStorage.removeItem("checkedOutNodeId");
  data = { nodes: {} }; // Reset data object
  edges.clear(); // Clear edges from DataSet
  nodes.clear(); // Clear nodes from DataSet
  document.getElementById("background-text").style.display = "flex"; // Show background text
}

function exportJSON() {
  const jsonData = JSON.stringify(data, null, 2);
  document.getElementById("json-data-textarea").value = jsonData;
}

// Function to import JSON data from the textarea
function importJSON() {
  const jsonData = document.getElementById("json-data-textarea").value;
  try {
    const parsedData = JSON.parse(jsonData);
    if (!parsedData.nodes) {
      throw new Error("Invalid JSON data.");
    }
    data = parsedData;
    const newNodes = {};
    const idMapping = {};

    // Generate UUIDs for nodes and create a mapping from old IDs to new UUIDs
    Object.values(parsedData.nodes).forEach((node) => {
      const oldId = node.id;
      const newId = uuid.v4();
      node.id = newId;
      idMapping[oldId] = newId;
      newNodes[newId] = node; // Use new UUID as key in the new nodes object
    });

    // Update parent references to use new UUIDs
    Object.values(newNodes).forEach((node) => {
      if (node.parent && idMapping[node.parent]) {
        node.parent = idMapping[node.parent];
      }
    });

    clearData();
    data.nodes = newNodes; // Replace old nodes object with new one using UUIDs as keys
    localStorage.setItem("data", JSON.stringify(data));

    updateVisualization(Object.values(data.nodes));

    // Check out the node with the latest lastRead value
    const lastRead = Object.values(data.nodes).find(
      (node) =>
        !node.lastRead ||
        node.lastRead ===
          Math.max(...Object.values(data.nodes).map((n) => n.lastRead)),
    );
    // Or the root if it doesn't exist
    if (lastRead) {
      network.selectNodes([lastRead.id]);
      localStorage.setItem("checkedOutNodeId", lastRead.id);
    } else {
      rootId = Object.values(data.nodes).find((node) => !node.parent).id;
      network.selectNodes([rootId]);
      localStorage.setItem("checkedOutNodeId", rootId);
    }

    // Hide the background text if there are nodes
    if (Object.keys(parsedData.nodes).length > 0) {
      document.getElementById("background-text").style.display = "none";
    }

    document.getElementById("json-data-textarea").value = "";
    document.getElementById("textEditor").style.display = "none";
    document.getElementById("settingsModal").style.display = "none";
    document.getElementById("background-text").style.display = "none";
  } catch (error) {
    console.error("Error parsing JSON:", error);
    alert("Invalid JSON data.");
  }
}

// Function to export a full html with the data embedded
function downloadHTML() {
  var htmlContent = document.documentElement.outerHTML;
  htmlContent = htmlContent.replace(
    "var data = { nodes: {} };",
    "var data = { nodes: " + JSON.stringify(data.nodes) + " };",
  );

  var blob = new Blob([htmlContent], { type: "text/html" });
  var url = URL.createObjectURL(blob);
  var a = document.createElement("a");
  a.href = url;
  a.download = "index.html";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
// Helper function to update a single node in the visualization
function updateNodeInVisualization(node) {
  const lastPatch =
    node.patches && node.patches.length > 0
      ? node.patches[node.patches.length - 1]
      : null;
  let label = lastPatch ? formatDiffsForDisplay(lastPatch.diffs) : node.text;
  if (node.hidden) {
    label = "...";
  }
  const nodeColor = {
    border: getNodeBorderColor(node.type),
  };
  if (node.hidden) {
    nodeColor.border = "rgba(0, 0, 0, 0.2)";
  }
  nodes.update({
    id: node.id,
    label: label,
    color: nodeColor,
    title:
      '<div class="info-box">' +
      (node.bookmarked ? "🌟" : "") +
      "<strong>Model:</strong> " +
      node.type +
      "</div>",
    parent: node.parent,
  });
  if (node.parent !== null) {
    edges.update({ from: node.parent, to: node.id });
  }
}

// Helper function to find the root node of a subtree given any node in the set
function findRootOfSubtree(node, allNodes) {
  let currentNode = node;
  while (
    currentNode.parent !== null &&
    allNodes.find((n) => n.id === currentNode.parent)
  ) {
    currentNode = allNodes[currentNode.parent];
  }
  return currentNode;
}

// Helper function to process nodes level by level in chunks
function processNodesByLevel(nodesToProcess, chunkSize) {
  // Create a set of all node IDs for quick lookup
  const allNodesSet = new Set(nodesToProcess.map((node) => node.id));
  // Find the root node of the subtree
  const rootNode = findRootOfSubtree(nodesToProcess[0], nodesToProcess);
  let queue = [rootNode]; // Initialize the queue with the root node
  let chunk = [];

  function processNextLevel() {
    let count = 0;
    while (queue.length > 0 && count < chunkSize) {
      const node = queue.shift(); // Dequeue the next node
      chunk.push(node);
      if (node.hidden) {
        continue; // Skip hidden nodes
      }
      const childNodes = findChildNodes(node.id, nodesToProcess);
      queue.push(...childNodes);
      count++;
    }

    // Process the current chunk
    chunk.forEach((node) => {
      updateNodeInVisualization(node); // Process only visible nodes
    });

    // // If the total length of new nodes is > 100, fit the view to the network
    // if (nodesToProcess.length > 10) {
    //   network.fit({ animation: true, locked: false });
    // }

    if (queue.length > 0) {
      setTimeout(processNextLevel, 100); // Schedule the next level
    }

    // Reset the chunk for the next iteration
    chunk = [];
  }

  processNextLevel(); // Start processing
}

// Modified updateVisualization function to use processNodesByLevel
function updateVisualization(newNodes) {
  if (newNodes.length === 0) {
    return;
  }
  var chunkSize = 50; // Define the chunk size
  if (newNodes.length > 150) {
    chunkSize = 1; // Define the chunk size
  }
  // Assuming newNodes contains the root nodes, otherwise find them
  processNodesByLevel(newNodes, chunkSize);
  // if (newNodes.length > 10) {
  //   network.fit({ animation: true, locked: false });
  // }
}
var dmp = new diff_match_patch();

var nodes = new vis.DataSet([]);
var edges = new vis.DataSet([]);
window.nodes = nodes;
window.edges = edges;

// Global variable to track if model colors are enabled
// Get the value from the toffle-model-colors checkbox
var useModelColors = document.getElementById("toggle-model-colors").checked;

function getNodeBorderColor(nodeType) {
  if (!useModelColors) {
    return "black"; // Return black when model colors are disabled
  }
  switch (nodeType) {
    case "mistral-instruct":
      return "blue";
    case "mixtral-instruct":
      return "green";
    case "mixtral":
      return "orange";
    case "llama2":
      return "purple";
    case "mistral":
      return "red";
    case "gpt3t":
      return "#afd7af";
    case "gpt4t":
      return "#d7afff";
    default:
      return "black"; // Default border color for unknown types
  }
}

// Function to update node colors based on the model type
function updateNodeColors() {
  nodes.forEach((node) => {
    const nodeColor = {
      border: getNodeBorderColor(data.nodes[node.id].type),
    };
    nodes.update([{ id: node.id, color: nodeColor }]);
  });
}

// Get the context menu element
var contextMenu = document.getElementById("nodeContextMenu");
// Create a network
const container = document.getElementById("mynetwork");

const visData = {
  nodes: nodes,
  edges: edges,
};
const options = {
  layout: {
    hierarchical: {
      sortMethod: "directed",
      direction: localStorage.getItem("direction") || "LR",
      levelSeparation: parseInt(localStorage.getItem("levelSeparation")) || 400,
      nodeSpacing: parseInt(localStorage.getItem("nodeSpacing")) || 250,
    },
  },
  nodes: {
    shape: "box",
    size: 20,
    color: {
      background: "white",
      border: "grey", // Default border color
      highlight: {
        background: "white",
        border: "black",
      },
    },
    font: {
      size: 20,
      multi: true, // Enable multi-line text
    },
    borderWidth: 2,
    widthConstraint: {
      maximum: 250,
    },
  },
  edges: {
    smooth: true,
    arrows: { to: true },
  },
  physics: { enabled: false },
};
const network = new vis.Network(container, visData, options);
updateTreeLayout();

// If data was already set, update the visualization
if (Object.keys(data.nodes).length) {
  updateVisualization(Object.values(data.nodes));

  // Check out the node with the latest lastRead value
  const lastRead = Object.values(data.nodes).find(
    (node) =>
      !node.lastRead ||
      node.lastRead ===
        Math.max(...Object.values(data.nodes).map((n) => n.lastRead)),
  );
  // Or the root if it doesn't exist
  if (lastRead) {
    network.selectNodes([lastRead.id]);
    localStorage.setItem("checkedOutNodeId", lastRead.id);
  } else {
    rootId = Object.values(data.nodes).find((node) => !node.parent).id;
    network.selectNodes([rootId]);
    localStorage.setItem("checkedOutNodeId", rootId);
  }
}

// Set the background color from local storage if it exists
const backgroundColor = localStorage.getItem("backgroundColor");
if (backgroundColor) {
  document.getElementById("mynetwork").style.backgroundColor = backgroundColor;
  document.getElementById("background-color-input").value = backgroundColor;
}

// Check if nodes are empty and display background text
if (!hasNonDataNodes()) {
  document.getElementById("background-text").style.display = "flex";
} else {
  document.getElementById("background-text").style.display = "none";
}

// Function to create a new node if the text has changed or if it's the first node
// Function to toggle the bookmark state of a node
function toggleBookmark(nodeId) {
  const node = data.nodes[nodeId];
  node.bookmarked = !node.bookmarked;
  updateVisualization([node]);
  localStorage.setItem("data", JSON.stringify(data));
}

// Function to toggle the visibility of a node and descendants
function toggleVisibility(nodeId) {
  const node = data.nodes[nodeId];
  node.hidden = !node.hidden;
  const descendents = findDescendentNodes(nodeId);
  // If node was unhidden, send it and all descendents to update
  if (!node.hidden) {
    updateVisualization([node].concat(descendents.map((id) => data.nodes[id])));
  } else {
    updateVisualization([node]);

    // If node was hidden, delete all its children
    descendents.forEach((id) => {
      nodes.remove(id);
    });
    edges.remove(
      edges.get({
        filter: function (edge) {
          return (
            descendents.includes(edge.from) || descendents.includes(edge.to)
          );
        },
      }),
    );
  }
  localStorage.setItem("data", JSON.stringify(data));

  // Check out the parent node and set it as selected
  const parentNodeId = findParentNode(nodeId);
  if (parentNodeId) {
    network.selectNodes([parentNodeId]);
    localStorage.setItem("checkedOutNodeId", parentNodeId);
  }
}

// Function to delete a node and all its descendants
function deleteNode(nodeId) {
  const node = data.nodes[nodeId];
  const parentNodeId = findParentNode(nodeId);
  var descendents = findDescendentNodes(nodeId);
  const nodesToDelete = [nodeId].concat(descendents);
  nodesToDelete.forEach((id) => {
    nodes.remove(id);
    delete data.nodes[id];
  });
  edges.remove(
    edges.get({
      filter: function (edge) {
        return (
          nodesToDelete.includes(edge.from) || nodesToDelete.includes(edge.to)
        );
      },
    }),
  );
  localStorage.setItem("data", JSON.stringify(data));

  // If there are no mode nodes, set the background text to visible
  if (!hasNonDataNodes()) {
    document.getElementById("background-text").style.display = "flex";
    localStorage.removeItem("checkedOutNodeId");
  }

  // Check out the parent node, and set it to selected
  if (parentNodeId) {
    network.selectNodes([parentNodeId]);
    localStorage.setItem("checkedOutNodeId", parentNodeId);
  }
  // And clear the data-node-id attribute
  document.getElementById("fullText").setAttribute("data-node-id", "");
}

function createNodeIfTextChanged(originalText, newText, parentId, type) {
  if (originalText !== newText || !hasNonDataNodes()) {
    // Text has changed, or it's the first node, create a new node
    const newNodeId = uuid.v4();
    const patches = dmp.patch_make(originalText, newText);
    data.nodes[newNodeId] = {
      id: newNodeId,
      text: dmp.patch_toText(patches),
      patches: patches,
      parent: parentId,
      type: type, // Store the type of the node
      bookmarked: false,
      hidden: false,
      createdAt: Date.now(),
    };

    // if the parentId was null, set the checkedOutNodeId to the new node
    if (parentId === null) {
      localStorage.setItem("checkedOutNodeId", newNodeId);
    }

    updateVisualization([data.nodes[newNodeId]]);
    // Save data to local storage
    localStorage.setItem("data", JSON.stringify(data));
    if (type === "human") {
      network.selectNodes([newNodeId]);
      localStorage.setItem("checkedOutNodeId", newNodeId);
    }
    // Hide the background text when the first node is created
    document.getElementById("background-text").style.display = "none";
  }
}

// Close the settings modal
document.getElementById("settingsModal").style.display = "none";

const resizeObserver = new ResizeObserver((entries) => {
  for (let entry of entries) {
    const { width, height } = entry.contentRect;
    const size = { width, height };
    // if new size is not 0, save it to local storage
    if (width !== 0 && height !== 0) {
      localStorage.setItem("textEditorSize", JSON.stringify(size));
    }
    // On page
  }
});

const fullText = document.getElementById("fullText");
resizeObserver.observe(fullText);
// Helper function to check if there are any non-data nodes in the network
function hasNonDataNodes() {
  return (
    nodes.get({
      filter: function (node) {
        return node.group !== "data";
      },
    }).length > 0
  );
}

// Function to format diffs for display
function formatDiffsForDisplay(diffs) {
  const deletions = diffs
    .filter((diff) => diff[0] === -1)
    .map((diff) => diff[1])
    .join(" ")
    .trim();
  const additions = diffs
    .filter((diff) => diff[0] === 1)
    .map((diff) => diff[1])
    .join(" ")
    .trim();
  const delStr = deletions ? `-${deletions}` : "";
  const addStr = additions ? `+${additions}` : "";
  return `${delStr} ${addStr}`.trim();
}

// Function to render the full text from patches
function renderFullTextFromPatches(nodeId) {
  let currentNode = data.nodes[nodeId];
  let pathToRoot = [];
  let fullText = "";

  // Traverse up the tree to collect the path to the root
  while (currentNode) {
    pathToRoot.push(currentNode);
    currentNode = data.nodes[currentNode.parent];
  }

  // Reverse the path to start from the root
  pathToRoot.reverse();

  // Apply the patches from the root to the current node
  pathToRoot.forEach((node) => {
    if (node.patches) {
      // Apply the patch to the current full text
      const patches = node.patches;
      const results = dmp.patch_apply(patches, fullText);
      fullText = results[0]; // Update the full text with the applied patch
    }
  });

  return fullText;
}

// Function to find the parent node of the current node
function findParentNode(nodeId) {
  const node = nodes.get(nodeId);
  return node && node.parent ? node.parent : null;
}

// Function to find the left and right sibling nodes of the current node
function findSiblingNodes(nodeId) {
  const parentNodeId = findParentNode(nodeId);
  if (parentNodeId === null) {
    return { leftSibling: null, rightSibling: null };
  }

  // Get the siblings and sort them. Use createdAt if available, otherwise fallback to UUID.
  const siblings = Object.values(data.nodes)
    .filter((node) => node.parent === parentNodeId && !node.hidden)
    .sort((a, b) => {
      if (a.createdAt && b.createdAt) {
        // Compare by createdAt if both are available
        return new Date(a.createdAt) - new Date(b.createdAt);
      } else {
        // Fallback to string comparison of UUIDs
        return a.id.localeCompare(b.id);
      }
    });

  // Find the index of the current node
  const currentIndex = siblings.findIndex((sibling) => sibling.id === nodeId);

  // Determine the left and right siblings, wrapping around at the ends
  const leftSiblingIndex =
    currentIndex > 0 ? currentIndex - 1 : siblings.length - 1;
  const rightSiblingIndex =
    currentIndex < siblings.length - 1 ? currentIndex + 1 : 0;

  return {
    leftSibling: siblings[leftSiblingIndex].id,
    rightSibling: siblings[rightSiblingIndex].id,
  };
}

function findLastReadOrRandomChildNode(parentNodeId) {
  // Filter out visible child nodes of the provided parent node
  const childNodes = Object.values(data.nodes).filter(
    (node) => !node.hidden && node.parent === parentNodeId,
  );

  if (childNodes.length === 0) {
    return null; // Return null if there are no child nodes
  }

  // Find the last read child node
  const lastReadNode = childNodes.reduce((acc, node) => {
    if (!acc || node.lastRead > acc.lastRead) {
      return node;
    }
    return acc;
  }, null);

  if (lastReadNode) {
    return lastReadNode.id; // Return the id of the last read child node
  }

  // If there is no last read child node, pick a random child node
  const randomIndex = Math.floor(Math.random() * childNodes.length);
  return childNodes[randomIndex].id;
}

// Function to find all the descendents of a node
function findDescendentNodes(nodeId) {
  let descendents = [];
  const children = Object.values(data.nodes).filter((n) => n.parent === nodeId);
  if (children.length > 0) {
    descendents = children.map((child) => child.id);
    children.forEach((child) => {
      descendents = descendents.concat(findDescendentNodes(child.id));
    });
  }
  return descendents;
}

function findChildNodes(nodeId, nodes) {
  return Object.values(nodes).filter((node) => node.parent === nodeId);
}

// Function to find all the descendants of a node and their depth
function findDescendentNodesWithDepth(nodeId, depth = 0) {
  let descendantsWithDepth = [];
  const children = Object.values(data.nodes).filter((n) => n.parent === nodeId);
  if (children.length > 0) {
    descendantsWithDepth = children.map((child) => ({
      id: child.id,
      depth: depth + 1,
    }));
    children.forEach((child) => {
      descendantsWithDepth = descendantsWithDepth.concat(
        findDescendentNodesWithDepth(child.id, depth + 1),
      );
    });
  }
  return descendantsWithDepth;
}

// Function to calculate the path stats for the current path
function getPathStats() {
  const checkedOutNodeId = localStorage.getItem("checkedOutNodeId");
  let currentNode = data.nodes[checkedOutNodeId];
  let pathToRoot = [];

  // Traverse up the tree to collect the path to the root
  while (currentNode) {
    pathToRoot.push(currentNode);
    currentNode = data.nodes[currentNode.parent];
  }

  // Count the occurrences of each model in the path
  const modelCounts = pathToRoot.reduce((counts, node) => {
    counts[node.type] = (counts[node.type] || 0) + 1;
    return counts;
  }, {});

  return modelCounts;
}

// Scoring system framework
const scoringAlgorithms = {
  averageDescendants: function (nodes) {
    const typeCounts = {};
    const typeTotals = {};

    Object.values(nodes).forEach((node) => {
      if (!node.hidden) {
        const descendants = findDescendentNodes(node.id);
        const type = node.type;
        typeCounts[type] = (typeCounts[type] || 0) + descendants.length;
        typeTotals[type] = (typeTotals[type] || 0) + 1;
      }
    });

    // Average by type
    const averages = {};
    for (const type in typeCounts) {
      averages[type] =
        typeTotals[type] > 0
          ? (typeCounts[type] / typeTotals[type]).toFixed(2)
          : 0;
    }

    // Sort the averages by value
    return Object.fromEntries(
      Object.entries(averages).sort(([, a], [, b]) => b - a),
    );
    return averages;
  },
  // Scoring algorithm for Normalized Proportion of Peer Descendants (NPPD)
  normalizedProportionOfPeerDescendants: function (nodes) {
    const nppdScores = {};

    Object.values(nodes).forEach((node) => {
      // Find all children of the current node
      const children = Object.values(nodes).filter(
        (child) => child.parent === node.id,
      );
      if (children.length === 0) {
        // If the node has no children, assign a default score of 1
        nppdScores[node.id] = 1;
      } else {
        // Calculate the total number of descendants for each child
        const totalDescendants = children.reduce((acc, child) => {
          const descendantsCount = findDescendentNodes(child.id).length;
          acc[child.id] = descendantsCount;
          return acc;
        }, {});
        // Calculate the total number of descendants across all children
        const sumOfDescendants = Object.values(totalDescendants).reduce(
          (acc, count) => acc + count,
          0,
        );
        // Calculate the NPPD score for each child
        children.forEach((child) => {
          const proportion =
            sumOfDescendants > 0
              ? totalDescendants[child.id] / sumOfDescendants
              : 0;
          const normalizedScore = proportion * children.length;
          nppdScores[child.id] = normalizedScore.toFixed(2);
        });
      }
    });

    // Average by type
    const typeCounts = {};
    const typeTotals = {};
    for (const [nodeId, nppd] of Object.entries(nppdScores)) {
      const type = data.nodes[nodeId].type;
      typeCounts[type] = (typeCounts[type] || 0) + parseFloat(nppd);
      typeTotals[type] = (typeTotals[type] || 0) + 1;
    }

    const averages = {};
    for (const type in typeCounts) {
      averages[type] =
        typeTotals[type] > 0
          ? (typeCounts[type] / typeTotals[type]).toFixed(2)
          : 0;
    }

    // Sort the averages by values
    return Object.fromEntries(
      Object.entries(averages).sort(([, a], [, b]) => b - a),
    );

    return averages;
  },
  discountedCumulativeGain: function (nodes) {
    const dcgScores = {};

    Object.values(nodes).forEach((node) => {
      let dcg = 0;
      const descendantsWithDepth = findDescendentNodesWithDepth(node.id);
      descendantsWithDepth.forEach((descendant) => {
        const relevance =
          data.nodes[descendant.id] && !data.nodes[descendant.id].hidden
            ? 1
            : 0;
        const position = descendant.depth;
        if (position === 1) {
          dcg += relevance; // rel_1
        } else {
          dcg += relevance / Math.log2(position + 1); // rel_i / log_2(i + 1)
        }
      });
      dcgScores[node.id] = dcg.toFixed(2);
    });

    // Average by type
    const typeCounts = {};
    const typeTotals = {};
    for (const [nodeId, dcg] of Object.entries(dcgScores)) {
      const type = data.nodes[nodeId].type;
      typeCounts[type] = (typeCounts[type] || 0) + parseFloat(dcg);
      typeTotals[type] = (typeTotals[type] || 0) + 1;
    }

    const averages = {};
    for (const type in typeCounts) {
      averages[type] =
        typeTotals[type] > 0
          ? (typeCounts[type] / typeTotals[type]).toFixed(2)
          : 0;
    }

    // Sort the averages by values
    return Object.fromEntries(
      Object.entries(averages).sort(([, a], [, b]) => b - a),
    );

    return dcgScores;
  },
};

// Function to update the stats in the info modal
function updatePathStats() {
  const statsContainer = document.getElementById("stats-container");
  const modelCounts = getPathStats();
  let statsHtml = "<ul>";

  // Title: Path Stats
  statsHtml += "<strong>Path Stats</strong>";

  for (const [model, count] of Object.entries(modelCounts)) {
    statsHtml += `<li>${model}: ${count}</li>`;
  }
  statsHtml += "</ul>";

  statsContainer.innerHTML += statsHtml;
}

// Function to calculate and return scores based on the selected algorithm
function calculateScores(algorithmName) {
  const algorithm = scoringAlgorithms[algorithmName];
  if (algorithm) {
    return algorithm(Object.values(data.nodes));
  } else {
    throw new Error(`Scoring algorithm "${algorithmName}" not found.`);
  }
}
// Add your additional code here to interact with the model
// Function to generate new output based on the given text and parent ID
function generateNewOutput(parentId) {
  const fullText = renderFullTextFromPatches(parentId);
  // Collect all active models and their configurations
  const activeModels = Array.from(
    document.querySelectorAll(".model-enable-checkbox:checked"),
  ).map((checkbox) => {
    const modelName = checkbox.id.replace("enable-", "");
    const isPinnedToDefault = document.getElementById(
      `pin-default-${modelName}`,
    ).checked;
    const modelConfigElement = document.getElementById(
      `model-config-${modelName}`,
    );
    const customModelConfig = isPinnedToDefault
      ? modelConfig
      : {
          max_tokens: parseInt(
            modelConfigElement.querySelector(`#max-tokens-input-${modelName}`)
              .value,
          ),
          temperature: parseFloat(
            modelConfigElement.querySelector(`#temperature-input-${modelName}`)
              .value,
          ),
          top_p: parseFloat(
            modelConfigElement.querySelector(`#top-p-input-${modelName}`).value,
          ),
          top_k: parseInt(
            modelConfigElement.querySelector(`#top-k-input-${modelName}`).value,
          ),
          repetition_penalty: parseFloat(
            modelConfigElement.querySelector(
              `#repetition-penalty-input-${modelName}`,
            ).value,
          ),
          stop: modelConfigElement
            .querySelector(`#stop-sequence-input-${modelName}`)
            .value.split(", "),
          n: parseInt(
            modelConfigElement.querySelector(`#completions-input-${modelName}`)
              .value,
          ),
        };
    return {
      model: modelName,
      config: customModelConfig,
    };
  });

  // Call the function to make an API call for text generation for each active model
  activeModels.forEach((model) => {
    for (let i = 0; i < (model.config.n || 1); i++) {
      generateText(fullText, parentId, model.model, model.config);
    }
  });
}

const prePrompt = `Return to completion mode. Complete the given sentence as best you can, with no commentary.
Return only the completion. If the prompt requires creativity, be creative.
DO NOT SAY 'here are some possible completions'. Just return the completion. If the completion expects you to respond as the user, respond as the user.

Examples:
Prompt: 'The quick brown fox'
Completion: 'jumps over the lazy dog.'
Prompt: 'The capital of France is'
Completion: 'Paris.'
Prompt: 'User: How are you today?\nHermes: I'm good, and you?'
Completion: '\nUser: I'm good too thanks!'

Only return the completion, not the word 'Completion'!`;

// Function to make an API call for text generation
function generateText(fullText, parentId, modelName, customConfig) {
  // Use custom config if provided, else clone the default modelConfig object
  var config = customConfig || Object.assign({}, modelConfig);
  var apiUrl = modelUrl[modelName];

  config.prompt = fullText;
  config.model = remoteName[modelName];

  let headers = {
    Authorization: "Bearer " + togetherApiKey,
  };

  // Determine which API to call based on the model name
  let apiCall;
  if (modelName.includes("gemini")) {
    // Call Google's API
    apiCall = callGoogleAPI(fullText, modelName, config);
  } else {
    // Set headers for axios call
    if (modelName.startsWith("gpt")) {
      headers = {
        "Content-Type": "application/json",
        Authorization: "Bearer " + openaiApiKey,
      };
      // OpenAI expects the prompt in a different format
      config = {
        messages: [
          {
            role: "system",
            content: prePrompt,
          },
          {
            role: "user",
            content: fullText,
          },
        ],
        max_tokens: config.max_tokens,
        temperature: config.temperature,
        top_p: config.top_p,
        stop: config.stop,
        model: remoteName[modelName],
      };
    } else if (modelName.includes("mistral-large")) {
      headers = {
        "Content-Type": "application/json",
        Accept: "application/json",
        Authorization: "Bearer " + mistralApiKey,
      };
      config = {
        messages: [
          {
            role: "system",
            content: prePrompt,
          },
          {
            role: "user",
            content: fullText,
          },
        ],
        temperature: config.temperature,
        top_p: config.top_p,
        max_tokens: config.max_tokens,
        model: remoteName[modelName],
      };
    }

    // Create a local copy of the config and delete n from it
    config = Object.assign({}, config);
    delete config.n;
    apiCall = axios({
      method: "post",
      url: apiUrl,
      data: config,
      headers: headers,
      responseType: "text",
    });
  }

  // Process the API call
  apiCall
    .then((result) => {
      let newText;
      // Check if the result is a string (from Google API) or an object (from axios)
      if (typeof result === "string") {
        // If it's a string, it's the text returned directly from the Google API
        newText = addSpace(healTokens(result), fullText);
      } else {
        // If it's an object, process the axios response to extract the text
        newText = processApiResponse(fullText, result, modelName);
      }
      // Create a new node with the generated text
      createNodeIfTextChanged(
        fullText,
        fullText + newText,
        parentId,
        modelName,
      );
    })
    .catch((error) => {
      console.error("Error during API call:", error);
    });
}

// Function to call Google's Generative AI API
function callGoogleAPI(fullText, modelName, config) {
  return new Promise(async (resolve, reject) => {
    if (!googleApiKey) {
      return reject(new Error("API key for Google Generative AI not found."));
    }

    const generationConfig = {
      maxOutputTokens: config.max_tokens,
      temperature: config.temperature,
      topP: config.top_p,
      topK: config.top_k,
      stopSequences: config.stop,
    };

    // Access your API key
    const genAI = new GoogleGenerativeAI(googleApiKey);

    const safetySettings = [
      {
        category: HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
      },
      {
        category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: HarmBlockThreshold.BLOCK_NONE,
      },
      {
        category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
      },
      {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
      },
    ];

    // Define the model name
    const model = genAI.getGenerativeModel({
      model: remoteName[modelName],
      safetySettings,
      generationConfig,
    });

    // Call the model's generate function with the provided config
    try {
      const result = await model.generateContentStream(prePrompt + fullText);
      let text = "";
      for await (const chunk of result.stream) {
        const chunkText = chunk.text();
        text += chunkText;
      }
      resolve(text);
    } catch (error) {
      console.error("Error calling Google Generative AI:", error);
    }
  });
}

function processApiResponse(fullText, response, modelName) {
  // Remove the "data:" prefix if it exists and parse the JSON
  const responseData = response.data.replace(/^data: /, "");
  const jsonResponse = JSON.parse(responseData);
  var newText = "";
  if (modelName.includes("mistral-large")) {
    // Mistral returns the response in a different format
    newText = healTokens(jsonResponse.choices[0].message.content);
  } else if (modelName.startsWith("gpt")) {
    // OpenAI returns the response in a different format
    newText = healTokens(jsonResponse.choices[0].message.content);
  } else {
    newText = healTokens(jsonResponse.choices[0].text);
  }
  return addSpace(newText, fullText);
}

// Token Healing: Eventually I want to add good token healing support. For now, we will just check if the last character is punctuation. If not, we will back up to the last space.
// We also strip any spaces at the start of the text.
function healTokens(text) {
  // Trim literal spaces, not newlines
  text = text.replace(/ +$/, "").replace(/^ +/, "");

  const lastChar = text[text.length - 1];
  const punctuation = ".!?}]);:,";
  if (punctuation.includes(lastChar)) {
    return text;
  }
  const lastSpace = text.lastIndexOf(" ");

  return text.slice(0, lastSpace);
}

function addSpace(newText, fullText) {
  // Add a space if the text has more than 2 characters and doesn't start with punctuation
  // And the fullText doesn't end in a newline
  if (
    newText.length > 2 &&
    !".!?,".includes(newText[0]) &&
    !fullText.endsWith("\n")
  ) {
    newText = " " + newText;
  }
  return newText;
}
// Event listener for the background text to open the modal on the first click
document
  .getElementById("background-text")
  .addEventListener("click", function () {
    // Check if the settings or configs are open, do nothing
    if (
      document.getElementById("settingsModal").style.display === "block" ||
      document.getElementById("model-config-modal").style.display === "block"
    ) {
      return;
    }

    if (!hasNonDataNodes()) {
      document.getElementById("background-text").style.display = "none";
      document.getElementById("textEditor").style.display = "block";
      document.getElementById("fullText").value =
        "(Tab to save and close the editor!\nEscape to close without saving!)";
    }
  });

network.on("click", function (params) {
  if (params.nodes.length > 0) {
    const nodeId = params.nodes[0];
    const textEditor = document.getElementById("textEditor");

    // Check if the settings or configs are open, do nothing
    if (
      document.getElementById("settingsModal").style.display === "block" ||
      document.getElementById("model-config-modal").style.display === "block"
    ) {
      return;
    }

    // Check if the text editor is open
    if (textEditor.style.display === "block") {
      const fullText = renderFullTextFromPatches(nodeId);

      // Update the full text in the editor
      const fullTextElement = document.getElementById("fullText");
      fullTextElement.value = fullText;
      // Ensure the text editor scrolls to the bottom after updates
      requestAnimationFrame(() => {
        fullTextElement.scrollTop = fullTextElement.scrollHeight;
      });
      fullTextElement.scrollTop = fullTextElement.scrollHeight;
      fullTextElement.setAttribute("data-node-id", nodeId);

      // Also, make the text editor no longer the active element.
      fullTextElement.blur();
    }

    // Save the last clicked node ID to localStorage
    network.selectNodes([nodeId]);
    localStorage.setItem("checkedOutNodeId", nodeId);

    // Set the read time on the node
    const currentNode = nodes.get(nodeId);
    currentNode.lastRead = Date.now();
  }
});

// Event listener for node clicks to show full text in a modal
network.on("doubleClick", function (params) {
  if (params.nodes.length > 0) {
    const nodeId = params.nodes[0];
    renderFullText(nodeId);
    document.getElementById("textEditor").style.display = "block";
  }
});

// Helper function to render and open fulltext
function renderFullText(nodeId) {
  const fullText = renderFullTextFromPatches(nodeId);
  const fullTextElement = document.getElementById("fullText");
  fullTextElement.value = fullText;
  // Ensure the text editor scrolls to the bottom after updates
  requestAnimationFrame(() => {
    fullTextElement.scrollTop = fullTextElement.scrollHeight;
  });
  fullTextElement.scrollTop = fullTextElement.scrollHeight;
  fullTextElement.setAttribute("data-node-id", nodeId);
}

// Add a tab event listener for opening and closing the editor
window.addEventListener("keydown", function (event) {
  const textEditor = document.getElementById("textEditor");
  const fullTextElement = document.getElementById("fullText");

  if (event.key === "Tab" || event.keyCode === 9) {
    if (document.getElementById("settingsModal").style.display === "block") {
      document.getElementById("settingsModal").style.display = "none";
    } else if (
      document.getElementById("model-config-modal").style.display === "block"
    ) {
      document.getElementById("model-config-modal").style.display = "none";
    } else if (document.getElementById("infoModal").style.display === "block") {
      document.getElementById("infoModal").style.display = "none";
    } else if (textEditor.style.display === "block") {
      // Get the current text from the modal
      const newText = fullTextElement.value.replace(/ +$/, "");
      // Set the trimmed text back to the modal
      fullTextElement.value = newText;
      var nodeId = fullTextElement.getAttribute("data-node-id");

      // If nodeId is null or NaN
      if (nodeId === null || isNaN(nodeId)) {
        nodeId = localStorage.getItem("checkedOutNodeId");
      }

      const originalText = renderFullTextFromPatches(nodeId);

      // Create a new node if the text has changed with type as 'human'
      createNodeIfTextChanged(originalText, newText, nodeId, "human");

      // Ensure the text editor scrolls to the bottom after updates
      requestAnimationFrame(() => {
        fullTextElement.scrollTop = fullTextElement.scrollHeight;
      });

      // Close the modal
      textEditor.style.display = "none";
      fullTextElement.scrollTop = fullTextElement.scrollHeight;
    } else {
      document.getElementById("background-text").style.display = "none";

      // Get the selected node
      const selectedNodeId = network.getSelectedNodes()[0];
      if (selectedNodeId) {
        renderFullText(selectedNodeId);
        document.getElementById("textEditor").style.display = "block";
      } else {
        const fullTextElement = document.getElementById("fullText");
        fullTextElement.setAttribute("data-node-id", selectedNodeId);
        document.getElementById("textEditor").style.display = "block";
      }

      // Focus on the full text element
      document.getElementById("fullText").focus();
    }
    event.preventDefault(); // Prevent the default context menu from showing
  }
});

// Event listener for the Escape key to close the modal regardless of focus
window.addEventListener("keydown", function (event) {
  if (
    (event.key === "Escape" || event.keyCode === 27) &&
    document.getElementById("textEditor").style.display === "block"
  ) {
    document.getElementById("textEditor").style.display = "none";
  }

  // If there are no nodes and the text editor is not open, show the background text
  if (
    Object.keys(data.nodes).length === 0 &&
    document.getElementById("textEditor").style.display === "none"
  ) {
    document.getElementById("background-text").style.display = "flex";
  }
});

// Event listener for the 'p' key to open settings
window.addEventListener("keydown", function (event) {
  if (event.key === "p" || event.keyCode === 80) {
    // if the editor is open, do nothing
    if (
      document.getElementById("textEditor").style.display === "block" ||
      document.getElementById("model-config-modal").style.display === "block"
    ) {
      return;
    }
    // Toggle the settings modal
    document.getElementById("settingsModal").style.display =
      document.getElementById("settingsModal").style.display === "block"
        ? "none"
        : "block";
  }
});

// Event listener for the 'm' key to open model configs
window.addEventListener("keydown", function (event) {
  if (event.key === "m" || event.keyCode === 77) {
    // if the editor is open, do nothing
    if (
      document.getElementById("textEditor").style.display === "block" ||
      document.getElementById("settingsModal").style.display === "block"
    ) {
      return;
    }
    // Toggle the model settings modal
    const modelConfig = document.getElementById("model-config-modal");
    modelConfig.style.display =
      modelConfig.style.display === "block" ? "none" : "block";
  }
});

// Event listener for the r key to generate new output
window.addEventListener("keydown", function (event) {
  if (event.key === "r" || event.keyCode === 82) {
    const fullTextElement = document.getElementById("fullText");
    // Check if the modal is open and focussed
    if (document.activeElement === fullTextElement) {
      return; // Exit the function if the modal is open
    }
    // Retrieve the last clicked node ID from localStorage
    const checkedOutNodeId = localStorage.getItem("checkedOutNodeId");

    if (checkedOutNodeId) {
      // Generate new output based on the checked-out node
      generateNewOutput(checkedOutNodeId);
    }
    event.preventDefault(); // Prevent the default action of the 'r' key
  }
});

// Event listener for the "Download" button
document.getElementById("btn-download").addEventListener("click", downloadHTML);

// Event listener for API key input to change background color
document
  .getElementById("together-api-key-input")
  .addEventListener("input", function (event) {
    const input = event.target;
    togetherApiKey = input.value.trim().replace(/^"|"$/g, "");
    if (togetherApiKey !== "") {
      // Save the API key to localStorage
      localStorage.setItem("togetherApiKey", togetherApiKey);
      input.style.backgroundColor = "green";
    } else {
      input.style.backgroundColor = "pink";
    }
  });
// Event listener for Google API key input to change background color
document
  .getElementById("google-api-key-input")
  .addEventListener("input", function (event) {
    const input = event.target;
    googleApiKey = input.value.trim().replace(/^"|"$/g, "");
    if (googleApiKey !== "") {
      // Save the API key to localStorage
      localStorage.setItem("googleApiKey", googleApiKey);
      input.style.backgroundColor = "green";
    } else {
      input.style.backgroundColor = "pink";
    }
  });
// Event listener for Mistral API key input to change background color
document
  .getElementById("mistral-api-key-input")
  .addEventListener("input", function (event) {
    const input = event.target;
    mistralApiKey = input.value.trim().replace(/^"|"$/g, "");
    if (mistralApiKey !== "") {
      // Save the API key to localStorage
      localStorage.setItem("mistralApiKey", mistralApiKey);
      input.style.backgroundColor = "green";
    } else {
      input.style.backgroundColor = "pink";
    }
  });

// Event listener for API key input to change background color
document
  .getElementById("openai-api-key-input")
  .addEventListener("input", function (event) {
    const input = event.target;
    openaiApiKey = input.value.trim().replace(/^"|"$/g, "");
    if (openaiApiKey !== "") {
      // Save the API key to localStorage
      localStorage.setItem("openaiApiKey", openaiApiKey);
      input.style.backgroundColor = "green";
    } else {
      input.style.backgroundColor = "pink";
    }
  });

// Event listener for model checkboxes to change model configuration
document.querySelectorAll(".model-checkbox").forEach((checkbox) => {
  checkbox.addEventListener("change", function (event) {
    const selectedModels = Array.from(
      document.querySelectorAll(".model-checkbox:checked"),
    ).map((checkbox) => checkbox.value);
  });
});

// Event listener for the 'Clear Data' button
document.getElementById("clear-data-btn").addEventListener("click", clearData);

// Event listener for the background color input
document
  .getElementById("background-color-input")
  .addEventListener("input", function (event) {
    const color = event.target.value;
    document.getElementById("mynetwork").style.backgroundColor = color;
    localStorage.setItem("backgroundColor", color);
  });

// Event listener for the tree layout settings inputs
document
  .getElementById("level-separation-input")
  .addEventListener("input", function (event) {
    localStorage.setItem("levelSeparation", event.target.value);
    updateTreeLayout();
  });
document
  .getElementById("node-spacing-input")
  .addEventListener("input", function (event) {
    localStorage.setItem("nodeSpacing", event.target.value);
    updateTreeLayout();
  });
document
  .getElementById("direction-select")
  .addEventListener("change", function (event) {
    localStorage.setItem("direction", event.target.value);
    updateTreeLayout();
  });

function updateTreeLayout() {
  // if level separation or node spacing are less than 50, set them to 50
  var levelSeparationNew =
    parseInt(localStorage.getItem("levelSeparation")) || 400;
  var nodeSpacingNew = parseInt(localStorage.getItem("nodeSpacing")) || 250;

  if (levelSeparationNew < 20) {
    levelSeparationNew = 20;
  }
  if (nodeSpacingNew < 20) {
    nodeSpacingNew = 20;
  }

  const levelSeparation = levelSeparationNew;
  const nodeSpacing = nodeSpacingNew;
  const direction = localStorage.getItem("direction") || "LR";
  network.setOptions({
    layout: {
      hierarchical: {
        levelSeparation: levelSeparation,
        nodeSpacing: nodeSpacing,
        direction: direction,
      },
    },
    edges: {
      smooth: true,
      arrows: { to: true },
    },
  });
}

// Event listener for the toggle model colors checkbox
document
  .getElementById("toggle-model-colors")
  .addEventListener("change", function (event) {
    useModelColors = event.target.checked;
    updateNodeColors();
  });

// Event listener for the export JSON button
document
  .getElementById("export-json-btn")
  .addEventListener("click", exportJSON);

// Event listener for the import JSON button
document
  .getElementById("import-json-btn")
  .addEventListener("click", importJSON);

// Attach context menu to the network
network.on("oncontext", function (params) {
  // Prevent default context menu from appearing
  params.event.preventDefault();
  // Check if the right-clicked element is a node
  const nodeId = this.getNodeAt(params.pointer.DOM);
  if (nodeId) {
    // Store the node ID in the context menu's data attribute
    contextMenu.setAttribute("data-node-id", nodeId);
    // Position the custom context menu at the pointer location
    contextMenu.style.top = params.pointer.DOM.y + "px";
    contextMenu.style.left = params.pointer.DOM.x + "px";
    // Display the custom context menu
    contextMenu.style.display = "block";
  }
});

// Hide the context menu when clicking elsewhere
network.on("click", function () {
  if (contextMenu.style.display === "block") {
    contextMenu.style.display = "none";
  }
});

// Event listeners for context menu actions
document.getElementById("hideNode").addEventListener("click", function () {
  const nodeId = contextMenu.getAttribute("data-node-id");
  if (nodeId) {
    toggleVisibility(nodeId);
  }
  contextMenu.style.display = "none";
});

document.getElementById("bookmarkNode").addEventListener("click", function () {
  const nodeId = contextMenu.getAttribute("data-node-id");
  if (nodeId) {
    toggleBookmark(nodeId);
  }
  contextMenu.style.display = "none";
});

document.getElementById("deleteNode").addEventListener("click", function () {
  const nodeId = contextMenu.getAttribute("data-node-id");
  if (nodeId) {
    deleteNode(nodeId);
  }
  contextMenu.style.display = "none";
});

// Event listener for the 'w', 'a', 'd', and 's' keys for navigation
window.addEventListener("keydown", function (event) {
  // Check if textEdit is both open and focussed
  if (
    document.getElementById("textEditor").style.display === "block" &&
    document.getElementById("fullText") == document.activeElement
  ) {
    return; // Do not navigate if the text editor is open
  }
  const checkedOutNodeId = localStorage.getItem("checkedOutNodeId");
  const selectedNodeId = network.getSelectedNodes()[0];
  const defaultTemperature = document.getElementById(
    "temperature-input-default",
  );

  const defaultTokens = document.getElementById("max-tokens-input-default");
  const direction = document.getElementById("direction-select");
  let targetNodeId = null;
  switch (event.key) {
    case "w":
      if (direction.value === "UD") {
        targetNodeId = findParentNode(checkedOutNodeId);
      } else {
        targetNodeId = findSiblingNodes(checkedOutNodeId).leftSibling;
      }
      break;
    case "a":
      if (direction.value === "UD") {
        targetNodeId = findSiblingNodes(checkedOutNodeId).leftSibling;
      } else {
        targetNodeId = findParentNode(checkedOutNodeId);
      }
      break;
    case "d":
      if (direction.value === "UD") {
        targetNodeId = findSiblingNodes(checkedOutNodeId).rightSibling;
      } else {
        targetNodeId = findLastReadOrRandomChildNode(checkedOutNodeId);
      }
      break;
    case "s":
      if (direction.value === "UD") {
        targetNodeId = findLastReadOrRandomChildNode(checkedOutNodeId);
      } else {
        targetNodeId = findSiblingNodes(checkedOutNodeId).rightSibling;
      }
      break;
    case "W":
      defaultTokens.value = parseInt(defaultTokens.value) + 20;
      modelConfig.max_tokens = parseInt(defaultTokens.value);
      updateDefaultConfigDisplay();
      break;
    case "A":
      defaultTemperature.value = parseFloat(defaultTemperature.value) - 0.1;
      modelConfig.temperature = parseFloat(defaultTemperature.value);
      updateDefaultConfigDisplay();
      break;
    case "D":
      defaultTemperature.value = parseFloat(defaultTemperature.value) + 0.1;
      modelConfig.temperature = parseFloat(defaultTemperature.value);
      updateDefaultConfigDisplay();
      break;
    case "S":
      defaultTokens.value = parseInt(defaultTokens.value) - 20;
      modelConfig.max_tokens = parseInt(defaultTokens.value);
      updateDefaultConfigDisplay();
      break;
    case " ":
      if (selectedNodeId) {
        toggleVisibility(selectedNodeId);
      }
      break;
    case "Enter":
      if (selectedNodeId) {
        toggleBookmark(selectedNodeId);
      }
      break;
    case "Delete":
      if (selectedNodeId) {
        deleteNode(selectedNodeId);
      }
      break;
    // case "Backspace":
    //   if (selectedNodeId) {
    //     deleteNode(selectedNodeId);
    //   }
    //   break;
    case "?":
      makeStats();
      break;
    default:
      return;
  }
  if (
    (document.getElementById("textEditor").style.display =
      "block" && targetNodeId !== null)
  ) {
    renderFullText(targetNodeId);
  }
  if (targetNodeId !== null) {
    // instead of focusing on it, just make sure it is highlighted
    network.selectNodes([targetNodeId]);
    localStorage.setItem("checkedOutNodeId", targetNodeId); // Save the new checked-out node ID
    const targetNode = data.nodes[targetNodeId];
    targetNode.lastRead = Date.now();
  }
});

function makeStats() {
  const statsContainer = document.getElementById("stats-container");

  // Tree stats: total number of nodes
  const totalNodes = Object.keys(data.nodes).length;
  let treeStatsHtml = `<strong>Total Nodes:</strong> ${totalNodes}<br>`;

  statsContainer.innerHTML = treeStatsHtml;

  // Update the path stats
  updatePathStats();

  // Calculate and update average descendants stats
  const averageDescendantsStats = calculateScores("averageDescendants");
  let statsHtml = "<ul><strong>Average Descendants by Node Type:</strong>";

  for (const [type, average] of Object.entries(averageDescendantsStats)) {
    statsHtml += `<li>${type}: ${average}</li>`;
  }
  statsHtml += "</ul>";

  statsContainer.innerHTML += statsHtml;

  // Calculate and update discounted cumulative gain stats
  const dcgStats = calculateScores("discountedCumulativeGain");
  let dcgHtml =
    "<ul><strong>Average Discounted Cumulative Gain by Model:</strong>";

  for (const [nodeId, dcg] of Object.entries(dcgStats)) {
    dcgHtml += `<li>${nodeId}: ${dcg}</li>`;
  }
  dcgHtml += "</ul>";

  statsContainer.innerHTML += dcgHtml;

  // Calculate and update normalized proportion of peer descendants
  const npdStats = calculateScores("normalizedProportionOfPeerDescendants");
  let npdHtml =
    "<ul><strong>Normalized Proportion of Peer Descendants by Model:</strong>";

  for (const [nodeId, npd] of Object.entries(npdStats)) {
    npdHtml += `<li>${nodeId}: ${npd}</li>`;
  }
  npdHtml += "</ul>";

  statsContainer.innerHTML += npdHtml;

  // Toggle the info modal display
  const infoModal = document.getElementById("infoModal");
  const isModalOpen = infoModal.style.display === "block";
  infoModal.style.display = isModalOpen ? "none" : "block";
  event.preventDefault();
}
function dragElement(elmnt) {
  var pos1 = 0,
    pos2 = 0,
    pos3 = 0,
    pos4 = 0;
  elmnt.onmousedown = dragMouseDown;

  function dragMouseDown(e) {
    // Do not execute the drag function if the target is a form element
    if (
      e.target.tagName === "INPUT" ||
      e.target.tagName === "TEXTAREA" ||
      e.target.tagName === "SELECT"
    ) {
      return;
    }
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = elmnt.offsetTop - pos2 + "px";
    elmnt.style.left = elmnt.offsetLeft - pos1 + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;
  }
}

// Make the DIV element draggable:
dragElement(document.getElementById("textEditor"));
const modelSanitized = [
  "gemma-7b",
  "mistral-7b-instruct",
  "mistral-7b",
  "mixtral-8x7b-instruct",
  "mixtral-8x7b",
  "llama-2-70b",
  "solar",
  "mistral-large",
  "gpt-35-turbo",
  "gpt-4-turbo",
  "gemini-pro",
];

const remoteName = {
  "gemma-7b": "google/gemma-7b",
  "mistral-7b-instruct": "mistralai/Mistral-7B-Instruct-v0.2",
  "mistral-7b": "mistralai/Mistral-7B-v0.1",
  "mixtral-8x7b-instruct": "mistralai/Mixtral-8x7B-Instruct-v0.1",
  "mixtral-8x7b": "mistralai/Mixtral-8x7B-v0.1",
  "llama-2-70b": "togethercomputer/llama-2-70b",
  solar: "upstage/SOLAR-10.7B-Instruct-v1.0",
  "gpt-35-turbo": "gpt-3.5-turbo",
  "gpt-4-turbo": "gpt-4-turbo-preview",
  "mistral-large": "mistral-large-latest",
  "gemini-pro": "gemini-pro",
};

const modelUrl = {
  "gemma-7b": "https://api.together.xyz/v1/completions",
  "mistral-7b-instruct": "https://api.together.xyz/v1/completions",
  "mistral-7b": "https://api.together.xyz/v1/completions",
  "mixtral-8x7b-instruct": "https://api.together.xyz/v1/completions",
  "mixtral-8x7b": "https://api.together.xyz/v1/completions",
  "llama-2-70b": "https://api.together.xyz/v1/completions",
  solar: "https://api.together.xyz/v1/completions",
  "gpt-35-turbo": "https://api.openai.com/v1/chat/completions",
  "gpt-4-turbo": "https://api.openai.com/v1/chat/completions",
  "mistral-large": "https://api.mistral.ai/v1/chat/completions",
  "gemini-pro": "https://generativelanguage.googleapis.com/v1beta/models/",
};

// Model configuration
var modelConfig = {
  model: "",
  max_tokens: 50,
  request_type: "language-model-inference",
  temperature: 0.7,
  top_p: 0.7,
  top_k: 50,
  repetition_penalty: 1,
  stream_tokens: false,
  stop: ["</s>"],
  n: 1,
};
window.modelConfig = modelConfig;

function saveModelConfigToLocalStorage(modelName) {
  const config = {
    max_tokens: parseInt(
      document.getElementById(`max-tokens-input-${modelName}`).value,
    ),
    temperature: parseFloat(
      document.getElementById(`temperature-input-${modelName}`).value,
    ),
    top_p: parseFloat(
      document.getElementById(`top-p-input-${modelName}`).value,
    ),
    top_k: parseFloat(
      document.getElementById(`top-k-input-${modelName}`).value,
    ),
    repetition_penalty: parseFloat(
      document.getElementById(`repetition-penalty-input-${modelName}`).value,
    ),
    stop: document
      .getElementById(`stop-sequence-input-${modelName}`)
      .value.split(", "),
    n: parseInt(
      document.getElementById(`completions-input-${modelName}`).value,
    ),
    pin_to_default: document.getElementById(`pin-default-${modelName}`)
      ? document.getElementById(`pin-default-${modelName}`).checked
      : false,
    is_active: document.getElementById(`enable-${modelName}`)
      ? document.getElementById(`enable-${modelName}`).checked
      : true,
  };
  // If model name contains 'default', dont save to local storage, update the default config
  if (modelName.includes("default")) {
    modelConfig = { ...modelConfig, ...config };
    updateDefaultConfigDisplay();
    return;
  }
  localStorage.setItem(`modelConfig-${modelName}`, JSON.stringify(config));
}

function loadModelConfigFromLocalStorage(modelName) {
  const config = JSON.parse(localStorage.getItem(`modelConfig-${modelName}`));
  if (config) {
    document.getElementById(`max-tokens-input-${modelName}`).value =
      config.max_tokens;
    document.getElementById(`temperature-input-${modelName}`).value =
      config.temperature;
    document.getElementById(`top-p-input-${modelName}`).value = config.top_p;
    document.getElementById(`top-k-input-${modelName}`).value = config.top_k;
    document.getElementById(`repetition-penalty-input-${modelName}`).value =
      config.repetition_penalty;
    document.getElementById(`stop-sequence-input-${modelName}`).value =
      config.stop.join(", ");
    document.getElementById(`completions-input-${modelName}`).value = config.n;
    if (document.getElementById(`pin-default-${modelName}`)) {
      document.getElementById(`pin-default-${modelName}`).checked =
        config.pin_to_default;
    }
    if (document.getElementById(`enable-${modelName}`)) {
      document.getElementById(`enable-${modelName}`).checked = config.is_active;
    }
    toggleConfigVisibility(
      modelName,
      document.getElementById(`model-config-${modelName}`),
    );
    updateDefaultConfigDisplay();
  }
}

function createModelConfigElement(modelName, isDefault = false) {
  const configSection = document.createElement("div");
  configSection.className = "model-config-blob";
  configSection.id = `model-config-${modelName}`;
  configSection.innerHTML = `
            <h3>${modelName}--on:
            ${
              isDefault
                ? ""
                : `<input type="checkbox" class="model-enable-checkbox" id="enable-${modelName}"><label for="pin-default-${modelName}"> use defaults: </label><input type="checkbox" id="pin-default-${modelName}" checked>`
            }
            </h3>
            <div class="model-config-fields">
            <label for="max-tokens-input-${modelName}">Max Tokens:</label>
            <input type="number" id="max-tokens-input-${modelName}" value="${modelConfig.max_tokens}" step="10"><br>
            <label for="temperature-input-${modelName}">Temperature:</label>
            <input type="number" step="0.1" id="temperature-input-${modelName}" value="${modelConfig.temperature}"><br>
            <label for="top-p-input-${modelName}">Top P:</label>
            <input type="number" step="0.1" id="top-p-input-${modelName}" value="${modelConfig.top_p}"><br>
            <label for="top-k-input-${modelName}">Top K:</label>
            <input type="number" id="top-k-input-${modelName}" value="${modelConfig.top_k}"><br>
            <label for="repetition-penalty-input-${modelName}">Repetition Penalty:</label>
            <input type="number" step="0.1" id="repetition-penalty-input-${modelName}" value="${modelConfig.repetition_penalty}"><br>
            <label for="stop-sequence-input-${modelName}">Stop Sequence:</label>
            <input type="text" id="stop-sequence-input-${modelName}" value="${modelConfig.stop.join(", ")}"><br>
            <label for="completions-input-${modelName}">Completions:</label>
            <input type="number" id="completions-input-${modelName}" value="${modelConfig.n}"><br>
            </div>
    `;
  // Attach event listeners to save config on change
  configSection.querySelectorAll("input").forEach((input) => {
    input.addEventListener("change", () =>
      saveModelConfigToLocalStorage(modelName),
    );
  });
  toggleConfigVisibility(modelName, configSection);
  return configSection;
}

function toggleConfigVisibility(modelName, configSection) {
  const enableCheckbox = configSection.querySelector(`#enable-${modelName}`);
  const pinnedCheckbox = configSection.querySelector(
    `#pin-default-${modelName}`,
  );
  const pinnedLabel = configSection.querySelector(
    `label[for=pin-default-${modelName}]`,
  );
  const configFields = configSection.querySelector(".model-config-fields");
  if (enableCheckbox) {
    enableCheckbox.addEventListener("change", () => {
      configFields.style.display =
        enableCheckbox.checked && !pinnedCheckbox.checked ? "block" : "none";
      pinnedCheckbox.style.display = enableCheckbox.checked ? "inline" : "none";
      pinnedLabel.style.display = enableCheckbox.checked ? "inline" : "none";
    });
    pinnedCheckbox.addEventListener("change", () => {
      configFields.style.display =
        enableCheckbox.checked && !pinnedCheckbox.checked ? "block" : "none";
    });
    // Set initial visibility based on checkbox state
    configFields.style.display =
      enableCheckbox.checked && !pinnedCheckbox.checked ? "block" : "none";
    pinnedCheckbox.style.display = enableCheckbox.checked ? "inline" : "none";
    pinnedLabel.style.display = enableCheckbox.checked ? "inline" : "none";
  }
}

window.addEventListener("DOMContentLoaded", function () {
  // Event listener for the API keys dropdown button
  document
    .getElementById("api-keys-dropdown-btn")
    .addEventListener("click", function (event) {
      document.getElementById("api-keys-container").classList.toggle("show");
    });

  const modelConfigContainer = document.getElementById(
    "model-params-container",
  );
  modelSanitized.forEach((model) => {
    const modelConfigElement = createModelConfigElement(model);
    modelConfigContainer.appendChild(modelConfigElement);
    // Load model configuration from localStorage
    loadModelConfigFromLocalStorage(model);
  });
  loadModelConfigFromLocalStorage("default");
  updateDefaultConfigDisplay();
});

// Close the API keys dropdown if the user clicks outside of it
window.onclick = function (event) {
  if (!event.target.matches("#api-keys-dropdown-btn")) {
    var apiKeysContainer = document.getElementById("api-keys-container");
    if (apiKeysContainer.classList.contains("show")) {
      apiKeysContainer.classList.remove("show");
    }
  }
};

function updateDefaultConfigDisplay() {
  const maxTokensDisplay = document.getElementById(
    "default-max-tokens-display",
  );
  const temperatureDisplay = document.getElementById(
    "default-temperature-display",
  );
  if (modelConfig) {
    maxTokensDisplay.textContent = `Max Tokens: ${modelConfig.max_tokens}`;
    const temperature = parseFloat(modelConfig.temperature);
    temperatureDisplay.textContent = `Temperature: ${temperature.toFixed(2)}`;
    const color = interpolateColor(temperature, 0.7, 0.99, {
      from: [76, 175, 80],
      to: [244, 67, 54],
    });
    temperatureDisplay.style.color = `rgb(${color.join(", ")})`;
  }
}

function interpolateColor(value, min, max, colors) {
  const ratio = (value - min) / (max - min);
  return colors.from.map((fromColor, index) => {
    const toColor = colors.to[index];
    return Math.round(fromColor + ratio * (toColor - fromColor));
  });
}

// Create a static default model config element using the default configuration
const defaultModelConfigElement = createModelConfigElement("default", true);
document
  .getElementById("default-params-container")
  .appendChild(defaultModelConfigElement); // Append to the default params container
</script>
</body>
</html>
