<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Tree Visualization</title>
    <!-- Load vis.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <!-- Load vis.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
    <!-- Load diff_match_patch library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch_uncompressed.js"></script>
    <!-- Load axios library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.7/axios.min.js"></script>
<style>
#mynetwork {
    width: 100%;
    height: 100vh;
}
</style>
    </style>
</head>
<body>
<script>
  // On page load, retrieve the API key from localStorage
  document.addEventListener('DOMContentLoaded', function() {
      const savedApiKey = localStorage.getItem('apiKey');
      if (savedApiKey) {
          const apiKeyInput = document.getElementById('api-key-input');
          apiKeyInput.value = savedApiKey.trim().replace(/^"|"$/g, '');
          apiKey = apiKeyInput.value;
          apiKeyInput.style.backgroundColor = 'green';
      }
  });
</script>
    <div style="position: absolute; top: 10px; right: 10px; z-index: 5;">
        <input type="password" id="api-key-input" placeholder="Enter API Key" style="background-color: pink;">
    </div>
    <div style="position: absolute; top: 10px; left: 10px; z-index: 5;">
        <button id="btn-top-down">Top-Down</button>
        <button id="btn-left-right">Left-Right</button>
    </div>
    <div id="mynetwork"></div>
    <!-- Modal container for full text display -->
    <div id="textModal" style="display:none; position:fixed; z-index:10; left:10%; top:10%; width:80%; height:80%; background-color:white; border:1px solid #ccc; overflow:auto;">
        <textarea id="fullText" style="width:100%; height:100%;"></textarea>
    </div>
    <script type="text/javascript">
      var dmp = new diff_match_patch();

      // Initialize demo data
      var data = {
        nodes: {
          1: {
            id: 1,
            text: 'Root Node',
            patches: dmp.patch_make('', 'Root Node'),
            parent: null
          },
          2: {
            id: 2,
            patches: dmp.patch_make('Root Node', 'Root Node with Child'),
            text: dmp.patch_toText(dmp.patch_make('Root Node', 'Root Node with Child')),
            parent: 1
          }
        }
      };

      var nodes = new vis.DataSet([]);
      // Global variable to store the API key
      var apiKey = '';
      var edges = new vis.DataSet([]);
      
      function cleanText(text) {
          // Remove everything up to and including the second plus sign in the text
          var plusIndex = text.indexOf('+');
          if (plusIndex >= 0) {
              text = text.substring(plusIndex + 1);
          }
          plusIndex = text.indexOf('+');
          if (plusIndex >= 0) {
              text = text.substring(plusIndex + 1);
          }
          return text
      }

      // Function to update the visualization with new nodes
      function updateVisualization(newNodes) {
        newNodes.forEach(node => {
          // Use the last patch to set the label, if available
          const lastPatch = node.patches && node.patches.length > 0 ? node.patches[node.patches.length - 1] : null;
          const label = lastPatch ? formatDiffsForDisplay(lastPatch.diffs) : node.text;
          nodes.update({id: node.id, label: label, title: node.text, group: node.type});
          if (node.parent !== null) {
            edges.update({from: node.parent, to: node.id});
          }
        });
      }

      updateVisualization(Object.values(data.nodes));

      // Convert the tree data to vis.js format
      const nodesArray = Object.values(data.nodes);
      updateVisualization(nodesArray);

      console.log("Processed nodes:", nodes);
      console.log("Processed edges:", edges);

      // Create a network
      const container = document.getElementById('mynetwork');
      const visData = {
          nodes: nodes,
          edges: edges
      };
      const options = {
        layout: {
          hierarchical: {
            sortMethod: "directed",
            levelSeparation: 200,
            nodeSpacing: 250,
          },
        },
        nodes: {
          shape: "box",
          size: 20,
          font: {
            size: 20,
            multi: true // Enable multi-line text
          },
          widthConstraint: {
            maximum: 150
          }
        },
        edges: {
          smooth: true,
          arrows: { to: true },
        },
        physics: {enabled: false}
      };
      const network = new vis.Network(container, visData, options);

      // Function to update the layout direction
      function updateLayoutDirection(direction) {
          const options = {
              layout: {
                  hierarchical: {
                      direction: direction
                  }
              }
          };
          network.setOptions(options);
      }

      // Event listeners for the layout direction buttons
      document.getElementById('btn-top-down').addEventListener('click', function() {
          updateLayoutDirection('UD'); // Top-Down
      });
      document.getElementById('btn-left-right').addEventListener('click', function() {
          updateLayoutDirection('LR'); // Left-Right
      });

      network.on("click", function (params) {
          if (params.nodes.length > 0) {
              const nodeId = params.nodes[0];
              const fullText = renderFullTextFromPatches(nodeId);

              // Save the last clicked node ID to localStorage
              localStorage.setItem('checkedOutNodeId', nodeId);
          }
      });

      // Event listener for node clicks to show full text in a modal
      network.on("doubleClick", function (params) {
          if (params.nodes.length > 0) {
              const nodeId = params.nodes[0];
              const fullText = renderFullTextFromPatches(nodeId);

              // Display the full text in a modal
              const textModal = document.getElementById('textModal');
              const fullTextElement = document.getElementById('fullText');
              fullTextElement.value = fullText;
              textModal.setAttribute('data-node-id', nodeId);
              textModal.style.display = 'block';
          }
      });

      // Function to create a new node if the text has changed
      function createNodeIfTextChanged(originalText, newText, parentId) {
        if (originalText !== newText) {
          // Text has changed, create a new node
          const newNodeId = Object.keys(data.nodes).length + 1;
          console.log(originalText, newText)
          const patches = dmp.patch_make(originalText, newText);
          data.nodes[newNodeId] = {
            id: newNodeId,
            text: dmp.patch_toText(patches),
            patches: patches,
            parent: parentId
          };

          updateVisualization([data.nodes[newNodeId]]);

        }
      }

      // Modify the event listener for the modal to call createNodeIfTextChanged
      window.addEventListener('contextmenu', function(event) {
        const textModal = document.getElementById('textModal');
        if (event.target === textModal || event.target === document.getElementById('fullText')) {
          // Get the current text from the modal
          const fullTextElement = document.getElementById('fullText');
          const newText = fullTextElement.value;
          const nodeId = parseInt(textModal.getAttribute('data-node-id'));
          const originalText = renderFullTextFromPatches(nodeId);

          // Create a new node if the text has changed
          createNodeIfTextChanged(originalText, newText, nodeId);

          // Close the modal
          textModal.style.display = 'none';
          event.preventDefault(); // Prevent the default context menu from showing
        }
      });

      // Event listener to close the modal when pressing the Escape key
      window.addEventListener('keydown', function(event) {
          if (event.key === 'Escape' || event.keyCode === 27) {
              const textModal = document.getElementById('textModal');
              if (textModal.style.display === 'block') {
                  textModal.style.display = 'none';
              }
          }
      });
      // Event listener for the '0' key to display the full JSON
      window.addEventListener('keydown', function(event) {
          if (event.key === 'j' || event.keyCode === 74) {
              // Display the full JSON
              console.log('Full JSON data:', JSON.stringify(data, null, 2));
              event.preventDefault(); // Prevent the default action of the '0' key
          }
      });

      // Function to format diffs for display
      function formatDiffsForDisplay(diffs) {
          const deletions = diffs.filter(diff => diff[0] === -1).map(diff => diff[1]).join(' ').trim();
          const additions = diffs.filter(diff => diff[0] === 1).map(diff => diff[1]).join(' ').trim();
          const delStr = deletions ? `-${deletions}` : '';
          const addStr = additions ? `+${additions}` : '';
          return `${delStr} ${addStr}`.trim();
      }

      // Function to render the full text from patches
      function renderFullTextFromPatches(nodeId) {
          let currentNode = data.nodes[nodeId];
          let pathToRoot = [];
          let fullText = '';

          // Traverse up the tree to collect the path to the root
          while (currentNode) {
              pathToRoot.push(currentNode);
              currentNode = data.nodes[currentNode.parent];
          }

          // Reverse the path to start from the root
          pathToRoot.reverse();

          // Apply the patches from the root to the current node
          pathToRoot.forEach(node => {
              if (node.patches) {
                  // Apply the patch to the current full text
                  const patches = node.patches;
                  const results = dmp.patch_apply(patches, fullText);
                  fullText = results[0]; // Update the full text with the applied patch
                  console.log('Patched text:', fullText)
              }
          });

          return fullText;
      }

      // Event listener for the ENTER key to generate new output
      window.addEventListener('keydown', function(event) {
          if (event.key === 'r' || event.keyCode === 82) {
              const textModal = document.getElementById('textModal');
              // Check if the modal is open, if so, do not generate new output
              if (textModal.style.display === 'block') {
                  return; // Exit the function if the modal is open
              }
              // Retrieve the last clicked node ID from localStorage
              const checkedOutNodeId = localStorage.getItem('checkedOutNodeId');
              if (checkedOutNodeId) {
                  // Generate new output based on the checked-out node
                  generateNewOutput(checkedOutNodeId);
              }
              event.preventDefault(); // Prevent the default action of the 'r' key
          }
      });

      // Function to generate new output based on the given text and parent ID
      function generateNewOutput(parentId) {
          const fullText = renderFullTextFromPatches(parentId);
          // Call the function to make an API call for text generation
          console.log('Generating text from text:', fullText);
          generateText(fullText, parentId);
      }
      // Function to make an API call for text generation
      function generateText(fullText, parentId) {
          axios({
              method: 'post',
              url: 'https://api.together.xyz/v1/completions',
              data: {
                  "model": "mistralai/Mixtral-8x7B-Instruct-v0.1",
                  "max_tokens": 50,
                  "prompt": fullText,
                  "request_type": "language-model-inference",
                  "temperature": 0.7,
                  "top_p": 0.7,
                  "top_k": 50,
                  "repetition_penalty": 1,
                  "stream_tokens": false,
                  "stop": ["</s>"]
              },
              headers: {
                  Authorization: 'Bearer ' + apiKey
              },
              responseType: 'text'
          }).then((response) => {
              // Remove the "data:" prefix if it exists and parse the JSON
              const responseData = response.data.replace(/^data: /, '');
              const jsonResponse = JSON.parse(responseData);
              const newText = jsonResponse.choices[0].text;
              console.log('Generated text:', newText);

              // Create a new node with the generated text
              createNodeIfTextChanged(fullText, newText, parentId);
          }).catch((error) => {
              console.error('Error during API call:', error);
          });
      }

      // Event listener for API key input to change background color
      document.getElementById('api-key-input').addEventListener('input', function(event) {
          const input = event.target;
          apiKey = input.value.trim().replace(/^"|"$/g, '');
          if (apiKey !== '') {
              // Save the API key to localStorage
              localStorage.setItem('apiKey', apiKey);
              input.style.backgroundColor = 'green';
          } else {
              input.style.backgroundColor = 'pink';
          }
      });

    </script>
</body>
</html>
