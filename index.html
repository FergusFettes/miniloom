<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Tree Visualization</title>
    <!-- Load vis.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <!-- Load vis.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
    <!-- Load diff_match_patch library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch_uncompressed.js"></script>
    <!-- Load axios library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.7/axios.min.js"></script>
<style>
#mynetwork {
    width: 100%;
    height: 100vh;
}
</style>
    </style>
</head>
<body>
<script>
  // On page load, retrieve the API key from localStorage
  document.addEventListener('DOMContentLoaded', function() {
      const savedApiKey = localStorage.getItem('apiKey');
      if (savedApiKey) {
          const apiKeyInput = document.getElementById('api-key-input');
          apiKeyInput.value = savedApiKey.trim().replace(/^"|"$/g, '');
          apiKey = apiKeyInput.value;
          apiKeyInput.style.backgroundColor = 'green';
      }
  });
</script>
    <div style="position: absolute; top: 10px; right: 10px; z-index: 5;">
        <input type="password" id="api-key-input" placeholder="Enter API Key" style="background-color: pink;">
<select id="model-dropdown" style="margin-left: 10px;">
    <option value="mistral-instruct">Mistral Instruct</option>
    <option value="mixtral-instruct">Mixtral Instruct</option>
    <option value="mixtral">Mixtral</option>
    <option value="llama2">LLaMA2</option>
    <option value="mistral">Mistral</option>
    <!-- Additional models can be added here -->
</select>
    </div>
    <div style="position: absolute; top: 10px; left: 10px; z-index: 5;">
        <button id="btn-top-down">Top-Down</button>
        <button id="btn-left-right">Left-Right</button>
    </div>
    <div id="mynetwork"></div>
    <div id="background-text" style="display:flex; align-items:center; justify-content:center; height:100vh;">Click to edit!</div>
    <!-- Modal container for full text display -->
    <div id="textModal" style="display:none; position:fixed; z-index:10; left:10%; top:10%; width:80%; height:80%; background-color:white; border:1px solid #ccc; overflow:auto;">
        <textarea id="fullText" style="width:100%; height:100%;"></textarea>
    </div>
    <script type="text/javascript">
      var dmp = new diff_match_patch();


      var nodes = new vis.DataSet([]);
      var edges = new vis.DataSet([]);

      // Initialize data object to store nodes and edges
      var data = {
        nodes: {},
        edges: {}
      };

      // Global variable to store the API key
      var apiKey = '';
      // Model configuration
      var modelConfig = {
          "model": "mistralai/Mixtral-8x7B-Instruct-v0.1",
          "max_tokens": 50,
          "request_type": "language-model-inference",
          "temperature": 0.7,
          "top_p": 0.7,
          "top_k": 50,
          "repetition_penalty": 1,
          "stream_tokens": false,
          "stop": ["</s>"]
      };

      // List of model aliases
      var modelAliases = {
          "mistral-instruct": "mistralai/Mistral-7B-Instruct-v0.2",
          "mixtral-instruct": "mistralai/Mixtral-8x7B-Instruct-v0.1",
          "mixtral": "mistralai/Mixtral-8x7B-v0.1",
          "llama2": "togethercomputer/llama-2-70b",
          "mistral": "mistralai/Mistral-7B-v0.1"
      };
      
      function cleanText(text) {
          // Remove everything up to and including the second plus sign in the text
          var plusIndex = text.indexOf('+');
          if (plusIndex >= 0) {
              text = text.substring(plusIndex + 1);
          }
          plusIndex = text.indexOf('+');
          if (plusIndex >= 0) {
              text = text.substring(plusIndex + 1);
          }
          return text
      }

      // Function to update the visualization with new nodes
      function updateVisualization(newNodes) {
        newNodes.forEach(node => {
          // Use the last patch to set the label, if available
          const lastPatch = node.patches && node.patches.length > 0 ? node.patches[node.patches.length - 1] : null;
          const label = lastPatch ? formatDiffsForDisplay(lastPatch.diffs) : node.text;
          nodes.update({id: node.id, label: label, title: node.text, group: node.type});
          if (node.parent !== null) {
            edges.update({from: node.parent, to: node.id});
          }
        });
      }

      updateVisualization(Object.values(data.nodes));

      // Convert the tree data to vis.js format
      const nodesArray = Object.values(data.nodes);
      updateVisualization(nodesArray);

      console.log("Processed nodes:", nodes);
      console.log("Processed edges:", edges);

      // Create a network
      const container = document.getElementById('mynetwork');
      const visData = {
          nodes: nodes,
          edges: edges
      };
      const options = {
        layout: {
          hierarchical: {
            sortMethod: "directed",
            levelSeparation: 200,
            nodeSpacing: 250,
          },
        },
        nodes: {
          shape: "box",
          size: 20,
          font: {
            size: 20,
            multi: true // Enable multi-line text
          },
          widthConstraint: {
            maximum: 150
          }
        },
        edges: {
          smooth: true,
          arrows: { to: true },
        },
        physics: {enabled: false}
      };
      const network = new vis.Network(container, visData, options);

      // Check if nodes are empty and display background text
      if (nodes.length === 0) {
          document.getElementById('background-text').style.display = 'flex';
      } else {
          document.getElementById('background-text').style.display = 'none';
      }

      // Function to update the layout direction
      function updateLayoutDirection(direction) {
          const options = {
              layout: {
                  hierarchical: {
                      direction: direction
                  }
              }
          };
          network.setOptions(options);
      }

      // Event listeners for the layout direction buttons
      document.getElementById('btn-top-down').addEventListener('click', function() {
          updateLayoutDirection('UD'); // Top-Down
      });
      document.getElementById('btn-left-right').addEventListener('click', function() {
          updateLayoutDirection('LR'); // Left-Right
      });

      network.on("click", function (params) {
          if (nodes.length === 0) {
              // Open the modal for the first node creation
              document.getElementById('textModal').style.display = 'block';
          } else if (params.nodes.length > 0) {
              const nodeId = params.nodes[0];
              const fullText = renderFullTextFromPatches(nodeId);

              // Save the last clicked node ID to localStorage
              localStorage.setItem('checkedOutNodeId', nodeId);
          }
      });

      // Event listener for node clicks to show full text in a modal
      network.on("doubleClick", function (params) {
          if (params.nodes.length > 0) {
              const nodeId = params.nodes[0];
              const fullText = renderFullTextFromPatches(nodeId);

              // Display the full text in a modal
              const textModal = document.getElementById('textModal');
              const fullTextElement = document.getElementById('fullText');
              fullTextElement.value = fullText;
              textModal.setAttribute('data-node-id', nodeId);
              textModal.style.display = 'block';
          }
      });

      // Function to create a new node if the text has changed or if it's the first node
      function createNodeIfTextChanged(originalText, newText, parentId, type) {
          if (originalText !== newText || nodes.length === 0) {
              // Text has changed, or it's the first node, create a new node
              const newNodeId = nodes.length === 0 ? 1 : Object.keys(data.nodes).length + 1;
              const patches = dmp.patch_make(originalText, newText);
              data.nodes[newNodeId] = {
                  id: newNodeId,
                  text: dmp.patch_toText(patches),
                  patches: patches,
                  parent: parentId,
                  type: type // Store the type of the node
              };

              updateVisualization([data.nodes[newNodeId]]);
              // Hide the background text when the first node is created
              document.getElementById('background-text').style.display = 'none';
          }
      }

    // Modify the event listener for the modal to call createNodeIfTextChanged with human type
    window.addEventListener('contextmenu', function(event) {
      const textModal = document.getElementById('textModal');
      if (event.target === textModal || event.target === document.getElementById('fullText')) {
        // Get the current text from the modal
        const fullTextElement = document.getElementById('fullText');
        const newText = fullTextElement.value;
        const nodeId = parseInt(textModal.getAttribute('data-node-id'));
        const originalText = renderFullTextFromPatches(nodeId);

        // Create a new node if the text has changed with type as 'human'
        createNodeIfTextChanged(originalText, newText, nodeId, 'human');

        // Close the modal
        textModal.style.display = 'none';
        event.preventDefault(); // Prevent the default context menu from showing
      }
      });

      // Event listener to close the modal when pressing the Escape key
      window.addEventListener('keydown', function(event) {
          if (event.key === 'Escape' || event.keyCode === 27) {
              const textModal = document.getElementById('textModal');
              if (textModal.style.display === 'block') {
                  textModal.style.display = 'none';
              }
          }
      });
      // Event listener for the '0' key to display the full JSON
      window.addEventListener('keydown', function(event) {
          if (event.key === 'j' || event.keyCode === 74) {
              // Display the full JSON
              console.log('Full JSON data:', JSON.stringify(data, null, 2));
              event.preventDefault(); // Prevent the default action of the '0' key
          }
      });

      // Function to format diffs for display
      function formatDiffsForDisplay(diffs) {
          const deletions = diffs.filter(diff => diff[0] === -1).map(diff => diff[1]).join(' ').trim();
          const additions = diffs.filter(diff => diff[0] === 1).map(diff => diff[1]).join(' ').trim();
          const delStr = deletions ? `-${deletions}` : '';
          const addStr = additions ? `+${additions}` : '';
          return `${delStr} ${addStr}`.trim();
      }

      // Function to render the full text from patches
      function renderFullTextFromPatches(nodeId) {
          let currentNode = data.nodes[nodeId];
          let pathToRoot = [];
          let fullText = '';

          // Traverse up the tree to collect the path to the root
          while (currentNode) {
              pathToRoot.push(currentNode);
              currentNode = data.nodes[currentNode.parent];
          }

          // Reverse the path to start from the root
          pathToRoot.reverse();

          // Apply the patches from the root to the current node
          pathToRoot.forEach(node => {
              if (node.patches) {
                  // Apply the patch to the current full text
                  const patches = node.patches;
                  const results = dmp.patch_apply(patches, fullText);
                  fullText = results[0]; // Update the full text with the applied patch
                  console.log('Patched text:', fullText)
              }
          });

          return fullText;
      }

      // Event listener for the ENTER key to generate new output
      window.addEventListener('keydown', function(event) {
          if (event.key === 'r' || event.keyCode === 82) {
              const textModal = document.getElementById('textModal');
              // Check if the modal is open, if so, do not generate new output
              if (textModal.style.display === 'block') {
                  return; // Exit the function if the modal is open
              }
              // Retrieve the last clicked node ID from localStorage
              const checkedOutNodeId = localStorage.getItem('checkedOutNodeId');
              
              if (checkedOutNodeId) {
                  // Generate new output based on the checked-out node
                  generateNewOutput(checkedOutNodeId);
              }
              event.preventDefault(); // Prevent the default action of the 'r' key
          }
      });

      // Function to generate new output based on the given text and parent ID
      function generateNewOutput(parentId) {
          const fullText = renderFullTextFromPatches(parentId);
          const selectedModelAlias = document.getElementById('model-dropdown').value;
          // Call the function to make an API call for text generation
          console.log('Generating text from text:', fullText);
          generateText(fullText, parentId, selectedModelAlias);
      }

      // Function to make an API call for text generation
      function generateText(fullText, parentId, type) {
          modelConfig.prompt = fullText;
          axios({
              method: 'post',
              url: 'https://api.together.xyz/v1/completions',
              data: modelConfig,
              headers: {
                  Authorization: 'Bearer ' + apiKey
              },
              responseType: 'text'
          }).then((response) => {
              // Remove the "data:" prefix if it exists and parse the JSON
              const responseData = response.data.replace(/^data: /, '');
              const jsonResponse = JSON.parse(responseData);
              const newText = ' ' + jsonResponse.choices[0].text;
              console.log('Generated text:', newText);

              // Create a new node with the generated text and the model type
              createNodeIfTextChanged(fullText, fullText + newText, parentId, type);
          }).catch((error) => {
              console.error('Error during API call:', error);
          });
      }

      // Event listener for API key input to change background color
      document.getElementById('api-key-input').addEventListener('input', function(event) {
          const input = event.target;
          apiKey = input.value.trim().replace(/^"|"$/g, '');
          if (apiKey !== '') {
              // Save the API key to localStorage
              localStorage.setItem('apiKey', apiKey);
              input.style.backgroundColor = 'green';
          } else {
              input.style.backgroundColor = 'pink';
          }
      });
// Event listener for model dropdown to change model configuration
document.getElementById('model-dropdown').addEventListener('change', function(event) {
    const selectedModelAlias = event.target.value;
    const selectedModel = modelAliases[selectedModelAlias];
    if (selectedModel) {
        modelConfig.model = selectedModel;
        console.log('Model changed to:', selectedModel);
    }
});

    </script>
</body>
</html>
